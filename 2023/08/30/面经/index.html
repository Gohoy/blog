<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java面经记录 | Hexo</title>
  <meta name="keywords" content=" Java , 面经 , 八股文 ">
  <meta name="description" content="Java面经记录 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="1. 背景因为使用obsidian的furigana插件来手动配置日语的假名太麻烦，我就想使用templater插件进行简化，但是还是几乎手动，提升很小，我就决定在网上找提供相关功能的接口，整合进来 2. 逆向接口我发现marumaru这个网站提供的功能正好是我想要的。网页比较简单，很简单就能获取到api浪费我很多时间的问题：header中必须包含的内容不全，导致返回的内容一直为空，也没有报错最终">
<meta property="og:type" content="article">
<meta property="og:title" content="obsidian 配置日语注音">
<meta property="og:url" content="https://gohoy.github.io/blog/2023/09/24/obsidian%20%E9%85%8D%E7%BD%AE%E6%97%A5%E8%AF%AD%E6%B3%A8%E9%9F%B3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 背景因为使用obsidian的furigana插件来手动配置日语的假名太麻烦，我就想使用templater插件进行简化，但是还是几乎手动，提升很小，我就决定在网上找提供相关功能的接口，整合进来 2. 逆向接口我发现marumaru这个网站提供的功能正好是我想要的。网页比较简单，很简单就能获取到api浪费我很多时间的问题：header中必须包含的内容不全，导致返回的内容一直为空，也没有报错最终">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gohoy.top/i/2023/09/24/ijo1qc-1.webp">
<meta property="article:published_time" content="2023-09-24T02:18:35.195Z">
<meta property="article:modified_time" content="2023-09-24T03:32:42.003Z">
<meta property="article:author" content="Gohoy">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="obsidian">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gohoy.top/i/2023/09/24/ijo1qc-1.webp">


<link rel="icon" href="/img/avatar.jpg">

<link href="/blog/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/blog/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/blog/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="/blog">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/"
   class="avatar_target">
    <img class="avatar"
         src="/blog/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Gohoy</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/gohoy"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:2738430398@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2738430398&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(22)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="吉他谱">
            
            吉他谱
            <small>(8)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="教程">
            
            教程
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="理论">
            
            理论
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="日语">
            
            日语
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="设计文档">
            
            设计文档
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="docker">
            
            docker
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Java">
            
            Java
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="K8S">
            
            K8S
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="22">
<input type="hidden" id="yelog_site_word_count" value="34.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>八股文</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>负载均衡</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>概率论</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>吉他谱</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>教程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面经</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>千恋万花</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计文档</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据结构</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>四子ding</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>掷筛</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>arm64</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Centos</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>contianer</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>https</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>K8S</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>leetcode</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mydisk</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NdS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>obsidian</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>openEuler</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springboot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ssl</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 日语 "
           href="/blog/2023/09/24/obsidian%20%E9%85%8D%E7%BD%AE%E6%97%A5%E8%AF%AD%E6%B3%A8%E9%9F%B3/"
           data-tag="教程,obsidian"
           data-author="" >
            <span class="post-title" title="obsidian 配置日语注音">obsidian 配置日语注音</span>
            <span class="post-date" title="2023-09-24 10:18:35">2023/09/24</span>
        </a>
        
        
        <a  class="All 日语 "
           href="/blog/2023/09/23/%E3%81%9B%E3%82%93%E3%82%8C%E3%82%93%E3%81%B0%E3%82%93%E3%81%8B/"
           data-tag="千恋万花"
           data-author="" >
            <span class="post-title" title="千恋万花学日语笔记">千恋万花学日语笔记</span>
            <span class="post-date" title="2023-09-23 00:39:56">2023/09/23</span>
        </a>
        
        
        <a  class="All Java "
           href="/blog/2023/09/19/%E7%AE%97%E6%B3%95/"
           data-tag="Java,算法,leetcode,数据结构"
           data-author="" >
            <span class="post-title" title="leetcode刷题">leetcode刷题</span>
            <span class="post-date" title="2023-09-19 16:42:04">2023/09/19</span>
        </a>
        
        
        <a  class="All Java "
           href="/blog/2023/09/11/springboot%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E5%AE%9E%E8%B7%B5/"
           data-tag="Java,springboot"
           data-author="" >
            <span class="post-title" title="springboot查询数据库字段实践">springboot查询数据库字段实践</span>
            <span class="post-date" title="2023-09-11 23:12:53">2023/09/11</span>
        </a>
        
        
        <a  class="All 教程 "
           href="/blog/2023/09/04/%E4%BD%BF%E7%94%A8Let's%20Encrypt%E7%BB%99%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0SSL/"
           data-tag="教程,ssl,https"
           data-author="" >
            <span class="post-title" title="使用Let&#39;s Encrypt给网站添加SSL">使用Let&#39;s Encrypt给网站添加SSL</span>
            <span class="post-date" title="2023-09-04 18:49:32">2023/09/04</span>
        </a>
        
        
        <a  class="All Java "
           href="/blog/2023/08/30/%E9%9D%A2%E7%BB%8F/"
           data-tag="Java,面经,八股文"
           data-author="" >
            <span class="post-title" title="Java面经记录">Java面经记录</span>
            <span class="post-date" title="2023-08-30 14:50:59">2023/08/30</span>
        </a>
        
        
        <a  class="All K8S "
           href="/blog/2023/08/30/k8s-web%E6%9C%80%E7%BB%88%E6%96%87%E6%A1%A3/"
           data-tag="K8S"
           data-author="" >
            <span class="post-title" title="K8S-WEB最终文档">K8S-WEB最终文档</span>
            <span class="post-date" title="2023-08-30 14:45:47">2023/08/30</span>
        </a>
        
        
        <a  class="All K8S "
           href="/blog/2023/08/30/%E9%87%8D%E8%A3%85k8s%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E6%A1%A3/"
           data-tag="K8S,教程,openEuler,arm64"
           data-author="" >
            <span class="post-title" title="openEuler安装K8S文档">openEuler安装K8S文档</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 理论 "
           href="/blog/2023/08/30/%E6%B8%B8%E6%88%8F%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E6%A6%82%E7%8E%87%E8%AE%BA/"
           data-tag="概率论,掷筛,NdS"
           data-author="" >
            <span class="post-title" title="游戏掷筛">游戏掷筛</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E5%B0%8F%E5%B9%B8%E8%BF%90%E5%90%89%E4%BB%96/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="小幸运吉他谱">小幸运吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E6%9C%AA%E9%97%BB%E8%8A%B1%E5%90%8D/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="未闻花名吉他谱">未闻花名吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 设计文档 "
           href="/blog/2023/08/30/%E5%9B%9B%E5%AD%90ding%20%E8%AE%BE%E8%AE%A1/"
           data-tag="设计文档,四子ding"
           data-author="" >
            <span class="post-title" title="四子ding设计">四子ding设计</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E8%AF%B4%E5%A5%BD%E7%9A%84%E5%B9%B8%E7%A6%8F%E5%91%A2/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="说好的幸福呢吉他谱">说好的幸福呢吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E6%99%B4%E5%A4%A9/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="晴天吉他谱">晴天吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E5%85%B0%E4%BA%AD%E5%BA%8F%E5%90%89%E4%BB%96%E8%B0%B1/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="兰亭序吉他谱">兰亭序吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E8%8A%B1%E6%B5%B7%E5%90%89%E4%BB%96%E8%B0%B1/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="花海吉他谱">花海吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All docker "
           href="/blog/2023/08/30/%E6%9E%84%E5%BB%BAopenEuler%E7%9A%84docker%E5%AE%B9%E5%99%A8/"
           data-tag="教程,docker,contianer,openEuler"
           data-author="" >
            <span class="post-title" title="openEuler docker container构建">openEuler docker container构建</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="爱在西元前吉他谱">爱在西元前吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 设计文档 "
           href="/blog/2023/08/30/Mydisk%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"
           data-tag="设计文档,Mydisk"
           data-author="" >
            <span class="post-title" title="Mydisk项目说明">Mydisk项目说明</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/Lemon%E5%90%89%E4%BB%96%E8%B0%B1/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="Lemon吉他谱">Lemon吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All K8S "
           href="/blog/2023/08/30/k8s%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/"
           data-tag="K8S,负载均衡"
           data-author="" >
            <span class="post-title" title="K8S负载均衡方案">K8S负载均衡方案</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All K8S "
           href="/blog/2023/08/30/CentOS%E5%AE%89%E8%A3%85K8S%E6%96%87%E6%A1%A3/"
           data-tag="Centos,K8S,教程"
           data-author="" >
            <span class="post-title" title="Centos7 安装 k8s">Centos7 安装 k8s</span>
            <span class="post-date" title="2023-08-30 14:25:32">2023/08/30</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-面经" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java面经记录</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java">Java</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">Java</a>
            
            <a class="color3">面经</a>
            
            <a class="color4">八股文</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2023-09-24 11:34:11'>2023-08-30 14:50</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:16.5k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">1. Java基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E6%98%AF%E7%BC%96%E8%AF%91%E5%92%8C%E8%A7%A3%E9%87%8A%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">1.1. 为什么说Java是编译和解释的语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.2. 静态方法中为什么不能调用非静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="toc-text">1.3. 重载和重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0public-void-test-String-%E2%80%A6args"><span class="toc-text">1.4. 可变长参数public void test(String …args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-text">1.5. 对象实体和对象引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%AF%B9%E8%B1%A1%E9%BB%98%E8%AE%A4%E6%9C%89%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%EF%BC%8C%E4%BD%86%E5%88%9B%E5%BB%BA%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%90%8E%E8%A6%81%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E3%80%82"><span class="toc-text">1.6. 对象默认有无参构造，但创建有参构造后要手动创建无参构造。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%A4%9A%E6%80%81"><span class="toc-text">1.7. 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.8. 接口和抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">1.9. 深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-Object-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">1.10. Object 的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-String-StringBuffer-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.11. String StringBuffer StringBuilder 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-String%E6%8B%BC%E6%8E%A5%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8Cintern%E6%96%B9%E6%B3%95"><span class="toc-text">1.12. String拼接、赋值和intern方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">1.13. 字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9B%86%E5%90%88"><span class="toc-text">2. 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-List"><span class="toc-text">2.1. List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Set"><span class="toc-text">2.2. Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%B1%BB%E5%88%AB%EF%BC%9A"><span class="toc-text">2.2.1. 类别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Set%E6%8E%92%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.2.2. Set排序接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7"><span class="toc-text">2.2.3. 无序性和不可重复性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Queue"><span class="toc-text">2.3. Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.3.1. 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-Queue%E5%92%8CDeque%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.3.2. Queue和Deque的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-ArrayDeque%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.3.3. ArrayDeque和LinkedList的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-PriorityQueue"><span class="toc-text">2.3.4. PriorityQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-BlockingQueue%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">2.3.5. BlockingQueue（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Map"><span class="toc-text">2.4. Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%B1%BB%E5%88%AB"><span class="toc-text">2.4.1. 类别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-HashMap%EF%BC%9A"><span class="toc-text">2.4.2. HashMap：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-HashTable%EF%BC%88%E6%8E%A5%E8%BF%91%E6%B7%98%E6%B1%B0%EF%BC%89%EF%BC%9A"><span class="toc-text">2.4.3. HashTable（接近淘汰）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-HashMap%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.4.4. HashMap和HashSet的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-TreeMap"><span class="toc-text">2.4.5. TreeMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">2.5. Collections工具类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E9%9B%86%E5%90%88%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-text">2.6. 集合的建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">3. 常用数据结构源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-HashMap%E6%BA%90%E7%A0%81"><span class="toc-text">3.1. HashMap源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ArrayList"><span class="toc-text">3.2. ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-LinkedList"><span class="toc-text">3.3. LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-ConcurrentHashMap"><span class="toc-text">3.4. ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">3.4.1. 实现线程安全的方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E4%B8%8D%E5%85%81%E8%AE%B8%E5%AD%98%E6%94%BEnull%E5%92%8Cnullkey"><span class="toc-text">3.4.2. 不允许存放null和nullkey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">3.4.3. 不能保证复合操作的原子性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">4. 并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4.1. synchronized关键字的底层原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-CAS%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4.2. CAS的理解和底层实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9CAtomicInterger%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">4.2.1. 线程操作AtomicInterger基本流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-CAS"><span class="toc-text">4.2.2. CAS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-JDK%E4%B8%AD%E7%9A%84AQS%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4.3. JDK中的AQS的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4.4. 线程池的底层工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A"><span class="toc-text">4.4.1. 线程池：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">4.4.2. 线程池的核心配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">4.4.3. 如果在线程池中使用无界阻塞队列会发生什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">4.4.4. 线程池队列满了之后，会发生什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5-%E5%A6%82%E6%9E%9C%E6%9C%BA%E5%99%A8%E7%AA%81%E7%84%B6%E5%AE%95%E6%9C%BA%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">4.4.5. 如果机器突然宕机，线程池的阻塞队列的任务怎么办</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-ThreadLocal"><span class="toc-text">4.5. ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-text">4.5.1. 内存泄漏问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Future%E7%B1%BB"><span class="toc-text">4.6. Future类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java-IO"><span class="toc-text">5. Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-InputStream"><span class="toc-text">5.1. InputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5.1.1. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-FileInputStream"><span class="toc-text">5.1.2. FileInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-DataInputStream"><span class="toc-text">5.1.3. DataInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-ObjectInputStream"><span class="toc-text">5.1.4. ObjectInputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-OutPutStream"><span class="toc-text">5.2. OutPutStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5.2.1. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-FileOutputStream"><span class="toc-text">5.2.2. FileOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-DataOutputStream"><span class="toc-text">5.2.3. DataOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-ObjectInputStream"><span class="toc-text">5.2.4. ObjectInputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Reader"><span class="toc-text">5.3. Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5.3.1. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-InputStreamReader-FileReader"><span class="toc-text">5.3.2. InputStreamReader FileReader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Writer"><span class="toc-text">5.4. Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5.4.1. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-OutputStreamWriter-FileWriter"><span class="toc-text">5.4.2. OutputStreamWriter FileWriter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81BufferedInputStream-BufferedOutputStream"><span class="toc-text">5.5. 字符缓冲流BufferedInputStream BufferedOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%89%93%E5%8D%B0%E6%B5%81-PrintStream"><span class="toc-text">5.6. 打印流 PrintStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81-RandomAccessFile"><span class="toc-text">5.7. 随机访问流 RandomAccessFile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%B0%88%E8%B0%88%E5%AF%B9Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">6. 谈谈对Java内存模型的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">6.1. 可见性、原子性、有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BB%8E%E5%BA%95%E5%B1%82%E8%A7%92%E5%BA%A6%E8%81%8Avolatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86"><span class="toc-text">6.2. 从底层角度聊volatile关键字原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%92%8Chappens-before%E5%8E%9F%E5%88%99"><span class="toc-text">6.3. 指令重排和happens-before原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-volatile%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">6.4. volatile底层如何基于内存屏障保证可见性和有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Spring"><span class="toc-text">7. Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Spring%E7%9A%84IOC"><span class="toc-text">7.1. Spring的IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Spring%E7%9A%84AOP"><span class="toc-text">7.2. Spring的AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E4%BA%86%E8%A7%A3%E8%BF%87cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%90%97%EF%BC%8C%E4%BB%96%E5%92%8Cjdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">7.3. 了解过cglib动态代理吗，他和jdk动态代理的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">7.4. spring事务的实现原理是什么，事务传播机制是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-Springboot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="toc-text">7.5. Springboot 的核心架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-Spring-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81"><span class="toc-text">7.6. Spring 核心源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">7.7. Spring中的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-SpringMVC%E6%9E%B6%E6%9E%84"><span class="toc-text">7.8. SpringMVC架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-SpringCloud%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="toc-text">7.9. SpringCloud核心架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-JVM"><span class="toc-text">8. JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-JVM%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E5%9D%97%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%8CJava8%E4%B9%8B%E5%90%8E%E5%AF%B9%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E6%94%B9%E8%BF%9B"><span class="toc-text">8.1. JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-JVM%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%90%84%E7%A7%8D%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.2. JVM如何运行起来的，如何创建各种对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-JVM%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">8.3. JVM什么时候会触发垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AF%B9%E8%B1%A1%E4%BC%9A%E8%BD%AC%E7%A7%BB%E5%88%B0%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">8.4. 什么时候对象会转移到老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6"><span class="toc-text">8.5. 常用的垃圾回收器，老年代如何回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEjvm%E5%8F%82%E6%95%B0%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5jvm%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="toc-text">8.6. 生产环境如何设置jvm参数的，如何检查jvm的运行情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-JVM-GC%E4%BC%98%E5%8C%96"><span class="toc-text">8.7. JVM GC优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E5%8F%91%E7%94%9FOOM%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E5%A4%84%E7%90%86%E7%BA%BF%E4%B8%8A%E7%B3%BB%E7%BB%9F%E7%9A%84OOM%E9%97%AE%E9%A2%98"><span class="toc-text">8.8. 发生OOM之后，应该如何排查和处理线上系统的OOM问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BD%91%E7%BB%9C"><span class="toc-text">9. 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-TCP-IP%E7%9A%84%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">9.1. TCP&#x2F;IP的四层模型和七层网络模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEbaidu-com%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">9.2. 浏览器访问baidu.com会发生什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%BA%94%E6%AC%A1%E6%88%96%E8%80%85%E4%B8%A4%E6%AC%A1%EF%BC%9F"><span class="toc-text">9.3. TCP三次握手和四次挥手的流程，为什么不是五次或者两次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E8%AF%B4%E4%B8%80%E4%B8%8Bhttp%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">9.4. 说一下http长连接的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-https-http-ssl-tsl"><span class="toc-text">9.5. https http+ssl&#x2F;tsl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-MySQL"><span class="toc-text">10. MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%BC%95%E6%93%8E%EF%BC%9Amysiam-innodb"><span class="toc-text">10.1. 引擎：mysiam innodb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%82"><span class="toc-text">10.2. Mysql索引原理和数据结构。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">10.3. 索引的使用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%89%B9%E7%82%B9"><span class="toc-text">10.4. 事务的几个特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">10.5. 隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81"><span class="toc-text">10.6. 数据库锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-MySQL%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%B8%E7%94%A8%E6%89%8B%E6%AE%B5"><span class="toc-text">10.7. MySQL调优的常用手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-E-R%E5%9B%BE"><span class="toc-text">10.8. E-R图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-socket"><span class="toc-text">11. socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">12. 进程通信和线程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">12.1. 进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2"><span class="toc-text">12.2. 线程如何切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-nio%EF%BC%8Cbio%EF%BC%8Caio%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82nio%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">13. nio，bio，aio都是什么，有什么区别。nio的原理是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-bio%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">13.1. bio通信原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-nio%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">13.2. nio通信原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-aio"><span class="toc-text">13.3. aio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">13.4. 同步阻塞、同步非阻塞、异步非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-BIO-NIO-AIO-demo%E4%BB%A3%E7%A0%81"><span class="toc-text">13.5. BIO NIO AIO demo代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98"><span class="toc-text">14. 线上服务器问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E7%BA%BF%E4%B8%8ACPU%E5%8D%A0%E7%94%A8100-%EF%BC%8C%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">14.1. 线上CPU占用100%，排查步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E5%A6%82%E6%9E%9C%E7%BA%BF%E4%B8%8A%E8%BF%9B%E7%A8%8Bkill%E4%B8%8D%E6%8E%89%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">14.2. 如果线上进程kill不掉怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E7%A3%81%E7%9B%98%E9%A9%AC%E4%B8%8A%E5%8D%A0%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">14.3. 磁盘马上占满了怎么办</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-text">15. Java语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">15.1. 参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">15.2. 序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">15.3. 泛型和通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E5%8F%8D%E5%B0%84"><span class="toc-text">15.4. 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-4-1-1-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">15.4.1.1. 基本操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">15.5. 代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-5-1-1-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="toc-text">15.5.1.1. 1.静态代理：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-5-1-2-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">15.5.1.2. 2.动态代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-6-BigDecimal%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">15.6. BigDecimal常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-7-Unsafe%E7%B1%BB"><span class="toc-text">15.7. Unsafe类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E7%AE%97%E6%B3%95"><span class="toc-text">16. 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95"><span class="toc-text">16.1. 字符串算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E5%8C%B9%E9%85%8D%E4%B8%B2%EF%BC%88KMP%EF%BC%89"><span class="toc-text">16.1.1. 字符串最长匹配串（KMP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-2-%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6"><span class="toc-text">16.1.2. 替换字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-3-%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D"><span class="toc-text">16.1.3. 最长前缀匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-4-%E6%9E%84%E5%BB%BA%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">16.1.4. 构建回文串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-5-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">16.1.5. 验证回文串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-6-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">16.1.6. 最长回文子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-7-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%B9%E9%85%8D%E6%B7%B1%E5%BA%A6"><span class="toc-text">16.1.7. 括号的匹配深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0"><span class="toc-text">16.1.8. 字符串转换为整数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95"><span class="toc-text">16.2. 链表算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-1-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-text">16.2.1. 两数相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-2-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">16.2.2. 反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E6%95%B0"><span class="toc-text">16.2.3. 链表中倒数第K个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-4-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-text">16.2.4. 合并两个排序的链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%E9%83%A8%E5%88%86%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE"><span class="toc-text">16.3. 部分常见题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">16.3.1. 斐波那契数列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-2-%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%9A%E4%B9%9F%E6%98%AF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">16.3.2. 跳台阶：也是斐波那契数列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-3-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E8%B7%B3n%E4%B8%AA"><span class="toc-text">16.3.3. 变态跳台阶：一个可以跳n个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE"><span class="toc-text">16.3.4. 二维数组查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-5-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-text">16.3.5. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-6-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text">16.3.6. 两个栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-7-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-text">16.3.7. 栈的压入弹出序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">16.4. 排序算法</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-5 i,
    .toc-level-5 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><h2 id="1-Java基础知识"><a href="#1-Java基础知识" class="headerlink" title="1. Java基础知识"></a>1. Java基础知识</h2><h3 id="1-1-为什么说Java是编译和解释的语言"><a href="#1-1-为什么说Java是编译和解释的语言" class="headerlink" title="1.1. 为什么说Java是编译和解释的语言"></a>1.1. 为什么说Java是编译和解释的语言</h3><p>Java需要把代码编译成.class的字节码文件，然后再解释成机器码。</p>
<h3 id="1-2-静态方法中为什么不能调用非静态方法"><a href="#1-2-静态方法中为什么不能调用非静态方法" class="headerlink" title="1.2. 静态方法中为什么不能调用非静态方法"></a>1.2. 静态方法中为什么不能调用非静态方法</h3><p>因为静态方法在类创建的时候生成，非静态方法在实例化对象之后才生成。</p>
<h3 id="1-3-重载和重写"><a href="#1-3-重载和重写" class="headerlink" title="1.3. 重载和重写"></a>1.3. 重载和重写</h3><p>重载：同方法名，不同参数</p>
<p>重写：子类重写父类的方法，方法名参数相同，构造方法无法重写</p>
<h3 id="1-4-可变长参数public-void-test-String-…args"><a href="#1-4-可变长参数public-void-test-String-…args" class="headerlink" title="1.4. 可变长参数public void test(String …args)"></a>1.4. 可变长参数public void test(String …args)</h3><p>可以接收不同长度的参数，重载的时候优先匹配固定长度参数的方法。</p>
<h3 id="1-5-对象实体和对象引用"><a href="#1-5-对象实体和对象引用" class="headerlink" title="1.5. 对象实体和对象引用"></a>1.5. 对象实体和对象引用</h3><p>new 来创建一个对象实体，一个对象实体可以有多个对象引用。一个对象引用可以指向一个对象实体。</p>
<p>对象实体存在堆内存中（类和对象都存放在堆内存中）</p>
<p>对象引用存放在栈内存中</p>
<h3 id="1-6-对象默认有无参构造，但创建有参构造后要手动创建无参构造。"><a href="#1-6-对象默认有无参构造，但创建有参构造后要手动创建无参构造。" class="headerlink" title="1.6. 对象默认有无参构造，但创建有参构造后要手动创建无参构造。"></a>1.6. 对象默认有无参构造，但创建有参构造后要手动创建无参构造。</h3><h3 id="1-7-多态"><a href="#1-7-多态" class="headerlink" title="1.7. 多态"></a>1.7. 多态</h3><p>子类在调用父类的方法的时候，只有在运行的时候，才知道调用的是哪个方法（父类的还是子类的），这个方法具有多态性</p>
<h3 id="1-8-接口和抽象类的区别"><a href="#1-8-接口和抽象类的区别" class="headerlink" title="1.8. 接口和抽象类的区别"></a>1.8. 接口和抽象类的区别</h3><ul>
<li>相同点：<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法，接口中可以定义default方法来实现</li>
</ul>
</li>
<li>不同点<ul>
<li>接口主要是对对象的约束，约束对象的行为（实现接口的方法）</li>
<li>抽象类主要是代码的复用性的规定</li>
<li>一个类只可以继承一个类，但可以实现多个接口</li>
<li>接口中 的成员变量只能是public static final 类型，有初值，不可变</li>
<li>抽象类中的成员变量默认为default，可在子类中重新定义和赋值</li>
</ul>
</li>
</ul>
<h3 id="1-9-深拷贝和浅拷贝"><a href="#1-9-深拷贝和浅拷贝" class="headerlink" title="1.9. 深拷贝和浅拷贝"></a>1.9. 深拷贝和浅拷贝</h3><p>浅拷贝：在对上创建一个新对象，如果被拷贝的是引用类型，则会直接复制它引用的地址</p>
<p>深拷贝：复制整个对象，包含内部对象</p>
<h3 id="1-10-Object-的常用方法"><a href="#1-10-Object-的常用方法" class="headerlink" title="1.10. Object 的常用方法"></a>1.10. Object 的常用方法</h3><pre><code class="java">/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class&lt;?&gt; getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * native 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable &#123; &#125;
</code></pre>
<p>hashcode 和 equals 都是判断对象是否相同的方法</p>
<p>hashcode 可能会碰撞，equals 是比较地址但效率较低</p>
<p>重写equals也应当重写hashcode方法。</p>
<h3 id="1-11-String-StringBuffer-StringBuilder-的区别"><a href="#1-11-String-StringBuffer-StringBuilder-的区别" class="headerlink" title="1.11. String StringBuffer StringBuilder 的区别"></a>1.11. String StringBuffer StringBuilder 的区别</h3><ul>
<li><p>String 对象不可变，String a &#x3D; “test”;  a &#x3D; “test1” 。更改a的值的时候，是创建了一个新的String对象，将地址赋给a。是线程安全的</p>
</li>
<li><p>StringBuffer 和 StringBuilder 更改值，不用新建对象。</p>
</li>
<li><p>StringBuffer 使用同步锁保证线程安全</p>
</li>
<li><p>StringBuilder 是线程不安全的，效率比StringBUffer快10%-15%</p>
</li>
</ul>
<h3 id="1-12-String拼接、赋值和intern方法"><a href="#1-12-String拼接、赋值和intern方法" class="headerlink" title="1.12. String拼接、赋值和intern方法"></a>1.12. String拼接、赋值和intern方法</h3><ul>
<li>在Java9之前，String 用加号连接的方法是使用StringBuilder.append().toString()方法构建的。在之后更新了方法，可以放心使用+连接，性能也不错</li>
<li>String s &#x3D; new String(“abc”); 这段代码可能会创建 1-2 个字符串对象。 先在字符串常量池创建一个字符串对象abc（如果已存在则不需要再创建），然后复制一份到堆内存中。</li>
<li>String intern 方法：将引用保存到字符串常量池中（如果已有则不再保存），并且返回这个对象</li>
</ul>
<h3 id="1-13-字符串常量池"><a href="#1-13-字符串常量池" class="headerlink" title="1.13. 字符串常量池"></a>1.13. 字符串常量池</h3><ul>
<li>字符串常量池位于<strong>堆内存</strong>中，与堆中的对象实例是分开的。</li>
<li>字符串常量池中的字符串是不可变的，一旦创建就不能修改。</li>
<li>字符串常量池中的字符串可以通过调用 intern() 方法进行显式的添加。该方法将返回常量池中字符串的引用，如果常量池中已存在相同内容的字符串，则返回已存在的引用。</li>
<li>字符串常量池的位置发生了变化，在 Java 7 及之前的版本中，字符串常量池位于永久代（PermGen），而在 Java 8 及以后的版本中，它被转移到了堆内存中。</li>
</ul>
<h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h2><h3 id="2-1-List"><a href="#2-1-List" class="headerlink" title="2.1. List"></a>2.1. List</h3><p>顺序存储</p>
<ul>
<li><p>ArrayList</p>
<ul>
<li>ArrayList和Array的区别</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>ArrayList</th>
<th>Array</th>
</tr>
</thead>
<tbody><tr>
<td>长度</td>
<td>可变</td>
<td>固定</td>
</tr>
<tr>
<td>用泛型</td>
<td>可</td>
<td>不可</td>
</tr>
<tr>
<td>存放类型</td>
<td>仅对象</td>
<td>对象和基本类型</td>
</tr>
<tr>
<td>内置方法</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>创建指定大小</td>
<td>无需</td>
<td>必须</td>
</tr>
<tr>
<td>存放null</td>
<td>可</td>
<td>不可</td>
</tr>
</tbody></table>
<pre><code>ArrayList和LinkedList操作的时间复杂度。
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>头插</td>
<td>O（n）</td>
<td>O（1）</td>
</tr>
<tr>
<td>尾插</td>
<td>O（1）或O（n） （扩容）</td>
<td>O（1）</td>
</tr>
<tr>
<td>中间插入</td>
<td>O（n）后面的要向后移动</td>
<td>O（n）找到插入的位置</td>
</tr>
<tr>
<td>头删</td>
<td>O（n）</td>
<td>O（1）</td>
</tr>
<tr>
<td>尾删</td>
<td>O（1）</td>
<td>O（1）</td>
</tr>
<tr>
<td>中间删除</td>
<td>O（n）</td>
<td>O（n）</td>
</tr>
</tbody></table>
<ul>
<li><p>Vector: <code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</p>
</li>
<li><p>LinkedList</p>
</li>
</ul>
<h3 id="2-2-Set"><a href="#2-2-Set" class="headerlink" title="2.2. Set"></a>2.2. Set</h3><h4 id="2-2-1-类别："><a href="#2-2-1-类别：" class="headerlink" title="2.2.1. 类别："></a>2.2.1. 类别：</h4><ul>
<li>HashSet：无序，唯一，使用HashMap实现</li>
<li>LinkedHashSet：使用LinkedHashMap实现</li>
<li>TreeSet：有序，唯一  也叫：红黑树 （自平衡的排序二叉树）</li>
</ul>
<h4 id="2-2-2-Set排序接口"><a href="#2-2-2-Set排序接口" class="headerlink" title="2.2.2. Set排序接口"></a>2.2.2. Set排序接口</h4><ul>
<li>Comparable：实现方法obj.compareTo(obj1);</li>
<li>Comparator：实现方法compare(obj1,obj2);</li>
</ul>
<h4 id="2-2-3-无序性和不可重复性"><a href="#2-2-3-无序性和不可重复性" class="headerlink" title="2.2.3. 无序性和不可重复性"></a>2.2.3. 无序性和不可重复性</h4><p>无序性：存储元素的顺序是按照key散列之后存储在对应位置，不是按顺序一个一个存储</p>
<p>不可重复性：equals不能相同，同时需要重写hashcode和equals方法</p>
<h3 id="2-3-Queue"><a href="#2-3-Queue" class="headerlink" title="2.3. Queue"></a>2.3. Queue</h3><h4 id="2-3-1-类型"><a href="#2-3-1-类型" class="headerlink" title="2.3.1. 类型"></a>2.3.1. 类型</h4><ul>
<li>PriorityQueue：数组实现的二叉堆</li>
<li>ArrayQueue：数组和双指针实现</li>
</ul>
<h4 id="2-3-2-Queue和Deque的区别"><a href="#2-3-2-Queue和Deque的区别" class="headerlink" title="2.3.2. Queue和Deque的区别"></a>2.3.2. Queue和Deque的区别</h4><p>Queue是单端队列，Deque是双端队列</p>
<p>Queue实现了Collection接口</p>
<p>Deque扩展了Queue接口，增加了队首删除和加入的方法，根据错误处理方式有两种不同操作方法</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法来模拟栈</p>
<h4 id="2-3-3-ArrayDeque和LinkedList的区别"><a href="#2-3-3-ArrayDeque和LinkedList的区别" class="headerlink" title="2.3.3. ArrayDeque和LinkedList的区别"></a>2.3.3. ArrayDeque和LinkedList的区别</h4><table>
<thead>
<tr>
<th></th>
<th>ArrayQueue</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>底层</td>
<td>数组+双指针</td>
<td>链表</td>
</tr>
<tr>
<td>可存储null</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>需要扩容</td>
<td>可能需要，但插入均摊性能高</td>
<td>否，但插入元素需要申请内存，均摊性能稍低</td>
</tr>
</tbody></table>
<p>ArrayQueue的性能比LinkedList好，并且可以实现栈。</p>
<h4 id="2-3-4-PriorityQueue"><a href="#2-3-4-PriorityQueue" class="headerlink" title="2.3.4. PriorityQueue"></a>2.3.4. PriorityQueue</h4><p>PriorityQueue和Queue的区别是：PriorityQueue是根据优先级出队的</p>
<p>细节TODO</p>
<h4 id="2-3-5-BlockingQueue（了解）"><a href="#2-3-5-BlockingQueue（了解）" class="headerlink" title="2.3.5. BlockingQueue（了解）"></a>2.3.5. BlockingQueue（了解）</h4><p>没有元素会阻塞，直到有元素。如果队列已满，会阻塞插入操作。</p>
<p>用来实现生产者消费者等部分。</p>
<h3 id="2-4-Map"><a href="#2-4-Map" class="headerlink" title="2.4. Map"></a>2.4. Map</h3><h4 id="2-4-1-类别"><a href="#2-4-1-类别" class="headerlink" title="2.4.1. 类别"></a>2.4.1. 类别</h4><ul>
<li>HashMap：不保证FIFO，不是先来先存储，通过散列，选择一个位置存放</li>
<li>LinkedHashMap：保证FIFO</li>
<li>HashTable：</li>
<li>TreeMap：</li>
</ul>
<h4 id="2-4-2-HashMap："><a href="#2-4-2-HashMap：" class="headerlink" title="2.4.2. HashMap："></a>2.4.2. HashMap：</h4><p>[hashMap](# HashMap源码)</p>
<h4 id="2-4-3-HashTable（接近淘汰）："><a href="#2-4-3-HashTable（接近淘汰）：" class="headerlink" title="2.4.3. HashTable（接近淘汰）："></a>2.4.3. HashTable（接近淘汰）：</h4><p>线程安全，效率稍低，不支持存储null或nullkey，容量默认为11，之后扩容为2n+1</p>
<h4 id="2-4-4-HashMap和HashSet的区别"><a href="#2-4-4-HashMap和HashSet的区别" class="headerlink" title="2.4.4. HashMap和HashSet的区别"></a>2.4.4. HashMap和HashSet的区别</h4><p>HashSet是HashMap实现的</p>
<p><code>HashSet</code> 的源码非常非常少，除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<ul>
<li>HashSet的去重：调用HashMap的add方法，根据返回值判断是否重复</li>
<li>HashMap的判断重复：计算hash值-&gt;相同equals-&gt;再相同则重复</li>
</ul>
<h4 id="2-4-5-TreeMap"><a href="#2-4-5-TreeMap" class="headerlink" title="2.4.5. TreeMap"></a>2.4.5. TreeMap</h4><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序</p>
<p>想要重写排序</p>
<pre><code class="java">TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person person1, Person person2) &#123;
                int num = person1.getAge() - person2.getAge();
                return Integer.compare(num, 0);
            &#125;
&#125;);
</code></pre>
<p>比HashMap多了元素根据键排序和对集合内元素的搜索能力</p>
<h3 id="2-5-Collections工具类方法"><a href="#2-5-Collections工具类方法" class="headerlink" title="2.5. Collections工具类方法"></a>2.5. Collections工具类方法</h3><pre><code class="java">//排序
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面

//查找 替换
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
</code></pre>
<p>同步操作（不推荐，建议使用JUC）</p>
<h3 id="2-6-集合的建议"><a href="#2-6-集合的建议" class="headerlink" title="2.6. 集合的建议"></a>2.6. 集合的建议</h3><ul>
<li><p>判空使用<code>isEmpty()</code>方法</p>
</li>
<li><p>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p>
</li>
<li><p>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。<code>Collection#removeIf()</code>方法删除满足特定条件的元素</p>
</li>
<li><p>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</p>
</li>
<li><p>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</p>
</li>
<li><p>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</p>
<ul>
<li><p>推荐解决方法</p>
<pre><code class="java">Integer [] myArray = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
</code></pre>
</li>
<li><p>最简单的解决办法</p>
<pre><code class="java">Integer [] myArray = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="3-常用数据结构源码解析"><a href="#3-常用数据结构源码解析" class="headerlink" title="3. 常用数据结构源码解析"></a>3. 常用数据结构源码解析</h2><h3 id="3-1-HashMap源码"><a href="#3-1-HashMap源码" class="headerlink" title="3.1. HashMap源码"></a>3.1. HashMap源码</h3><ul>
<li><p>底层是数组+链表+红黑树，非线程安全</p>
<ul>
<li>为什么非线程安全<ul>
<li><p>线程一进行完hash碰撞判断之后，时间片用尽，线程二完成了hash计算和插入操作，此时线程一直接插入，会覆盖线程二插入的值</p>
</li>
<li><p>同时put导致size值不对</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可存储null的key和value</p>
</li>
<li><p>初始大小16，扩容到当前的二倍（一定是2的幂次方，便于取余计算）</p>
</li>
<li><p>获取Key的方法：</p>
<ul>
<li><pre><code class="java">static final int hash(Object key) &#123;
  int h;
  // key.hashCode()：返回散列值也就是hashcode
  // ^：按位异或
  // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐
  return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>元素添加：</p>
<ul>
<li>获取数组的index：key对hashmap的length取模（将key和length-1与，比%取模的性能好）</li>
<li>如果这个index没有元素，直接添加</li>
<li>如果有元素则比较key，如果key相同则覆盖。</li>
<li>如果是hash碰撞，则判断是否是树节点，是就调用putTreeVal加入树节点，否则加入链表尾部</li>
</ul>
</li>
<li><p>hash碰撞使用拉链法</p>
<ul>
<li>在hash碰撞的节点创建一个链表，把碰撞的值都放在链表中</li>
<li>链表元素超过8个，将链表切换成红黑树</li>
</ul>
</li>
<li><p>扩容条件是存放的元素数量超过<code>容量*负载因子</code></p>
<ul>
<li>负载因子<strong>loadFactor</strong> 是控制数组存放数据的疏密程度<ul>
<li>loadFactor越趋近1，数组中存储的元素就越多，碰撞的元素在链表的长度就越多，查询性能下降</li>
<li>loadFactor越趋近0，hashMap扩容次数增加，rehash消耗性能</li>
<li>官方给出的默认为0.75</li>
</ul>
</li>
<li>resize就是扩容之后重新计算index和hash<ul>
<li>底层就是新开一个数组，将元素重新放入新数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-ArrayList"><a href="#3-2-ArrayList" class="headerlink" title="3.2. ArrayList"></a>3.2. ArrayList</h3><ul>
<li><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。线程不安全。</p>
<ul>
<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>RandomAccess</code> ：表明它可以快速进行随机访问，get(index)</li>
<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>
<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>
</ul>
</li>
<li><p>可以添加null值。</p>
</li>
<li><p>底层是Object数组。</p>
</li>
<li><p>时间复杂度：add() O(1) ;   add(index,val) O(n) ;</p>
</li>
<li><p>空间占用主要是末尾预留的空间。</p>
</li>
<li><p>在添加大量元素的时候，可以提前使用ensureCapacity(N)方法预留空间，减少空间分配次数，节约性能。</p>
</li>
<li><p>当添加元素大于容量的时候，触发扩容</p>
<ul>
<li>扩容：每次newSize&#x3D; oldSize+oldSize&#x2F;2 相当于1.5倍</li>
</ul>
</li>
</ul>
<h3 id="3-3-LinkedList"><a href="#3-3-LinkedList" class="headerlink" title="3.3. LinkedList"></a>3.3. LinkedList</h3><ul>
<li><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</li>
<li><code>LinkedList</code> 实现了<code>List</code>,<code>Deque</code>,<code>Cloneable</code>,<code>Seralizable</code><ul>
<li><code>Deque</code>：表明它具有双端队列特性，便于两端插入和删除</li>
</ul>
</li>
<li>底层是双向链表</li>
<li>时间复杂度：add() O(1); add(index,val) O(n) </li>
<li>空间占用主要是除了data之外的索引等数据</li>
<li>遍历常用for-each</li>
<li>基本上不用LinkedList，都用ArrayList，性能一般更好一些</li>
</ul>
<h3 id="3-4-ConcurrentHashMap"><a href="#3-4-ConcurrentHashMap" class="headerlink" title="3.4. ConcurrentHashMap"></a>3.4. ConcurrentHashMap</h3><h4 id="3-4-1-实现线程安全的方法："><a href="#3-4-1-实现线程安全的方法：" class="headerlink" title="3.4.1. 实现线程安全的方法："></a>3.4.1. 实现线程安全的方法：</h4><ul>
<li>JDK1.7的时候：使用Segment数组（锁的个数，默认16，不可扩容）+HashEntry数组+链表实现。使用分段锁，将数据分段保护。最多支持16个线程并发（默认）</li>
<li>JDK1.8的时候：使用（node数组+链表）&#x2F;（红黑树）实现。主要使用CAS和synchronized操作，保留一些分段锁用来兼容旧版本。synchronized锁定链表节点或者红黑树首节点。因此只要hash不碰撞都可以进行并发操作。</li>
</ul>
<h4 id="3-4-2-不允许存放null和nullkey"><a href="#3-4-2-不允许存放null和nullkey" class="headerlink" title="3.4.2. 不允许存放null和nullkey"></a>3.4.2. 不允许存放null和nullkey</h4><p>避免二义性，不同线程使用containsKey来判断是否存在元素，如果存储null就不知道到底是有还是没有值。</p>
<h4 id="3-4-3-不能保证复合操作的原子性"><a href="#3-4-3-不能保证复合操作的原子性" class="headerlink" title="3.4.3. 不能保证复合操作的原子性"></a>3.4.3. 不能保证复合操作的原子性</h4><pre><code class="java">// 线程 A
if (!map.containsKey(key)) &#123;
map.put(key, value);
&#125;
// 线程 B
if (!map.containsKey(key)) &#123;
map.put(key, anotherValue);
&#125;
</code></pre>
<p>不能保证上面的代码正常执行</p>
<p>concurrentHashMap提供了原子性的符合操作方法：<code>putIfAbsent()</code>或<code>computeIfAbsent()</code></p>
<h2 id="4-并发编程"><a href="#4-并发编程" class="headerlink" title="4. 并发编程"></a>4. 并发编程</h2><h3 id="4-1-synchronized关键字的底层原理是什么"><a href="#4-1-synchronized关键字的底层原理是什么" class="headerlink" title="4.1. synchronized关键字的底层原理是什么"></a>4.1. synchronized关键字的底层原理是什么</h3><p>2.1.1synchronized是做什么的</p>
<p><strong>给线程加锁</strong>，加锁目标是一个类或一个对象。</p>
<p>2.1.2实现原理</p>
<p>加锁指令：monitorenter（加锁） monitorexit（释放锁）</p>
<p>一个对象或类关联有一个monitor（计数器：正在使用的线程数，<strong>类似信号量</strong>）</p>
<h3 id="4-2-CAS的理解和底层实现原理"><a href="#4-2-CAS的理解和底层实现原理" class="headerlink" title="4.2. CAS的理解和底层实现原理"></a>4.2. CAS的理解和底层实现原理</h3><p>多个线程要访问同一个数据会出现并发安全问题。</p>
<p><code>AtomicInterger</code>并发包的原子类，使用CAS实现。</p>
<h4 id="4-2-1-线程操作AtomicInterger基本流程："><a href="#4-2-1-线程操作AtomicInterger基本流程：" class="headerlink" title="4.2.1. 线程操作AtomicInterger基本流程："></a>4.2.1. 线程操作AtomicInterger基本流程：</h4><p>线程1想要修改值，会</p>
<ul>
<li>先读取旧值</li>
<li>在修改前再次读取这个值</li>
<li>如果没人修改，则使用CAS进行修改这个值。</li>
<li>如果第二次读取的值和旧值不同，则CAS失败。</li>
</ul>
<h4 id="4-2-2-CAS"><a href="#4-2-2-CAS" class="headerlink" title="4.2.2. CAS"></a>4.2.2. CAS</h4><p>CAS：compare and set</p>
<p>在硬件级别保是原子操作，同一时间只有一个线程可以执行CAS。</p>
<p>ABA问题：线程1读取值A，线程2读取值A修改成B之后再修改成A，这样线程1不知道是不是被修改了。</p>
<p>解决：加上时间戳（版本号）</p>
<h3 id="4-3-JDK中的AQS的实现原理"><a href="#4-3-JDK中的AQS的实现原理" class="headerlink" title="4.3. JDK中的AQS的实现原理"></a>4.3. JDK中的AQS的实现原理</h3><p><code>ReentrantLock </code>类底层是AQS（Abstract Queue Synchronizer）</p>
<p>可以使用这个类生成一个锁lock，可以进行lock.lock() lock.unlock()实现互斥。</p>
<p>2.4.1 AQS会有一个等待队列，存储没有得到锁的线程，待锁释放后，按顺序为等待队列的线程提供锁</p>
<img src="http://gohoy.top/i/2023/07/31/ui6crn-1.png" alt="image-20230731160209376" style="zoom:80%;" />

<p>2.4.2如果在线程1执行完毕，唤醒线程2的过程中，如果有线程3想要加锁</p>
<ul>
<li>非公平锁：ReentrantLock lock &#x3D; new ReentrantLock()；<ul>
<li>线程3可能会成功得到锁，达到插队。</li>
</ul>
</li>
<li>公平锁：ReentrantLock lock &#x3D; new ReentrantLock(true);<ul>
<li>如果等待队列有线程，线程3会进入等待队列。</li>
</ul>
</li>
</ul>
<h3 id="4-4-线程池的底层工作原理"><a href="#4-4-线程池的底层工作原理" class="headerlink" title="4.4. 线程池的底层工作原理"></a>4.4. 线程池的底层工作原理</h3><p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险（阿里巴巴Java规范）</p>
<h4 id="4-4-1-线程池："><a href="#4-4-1-线程池：" class="headerlink" title="4.4.1. 线程池："></a>4.4.1. 线程池：</h4><p>提供一定量的线程，线程执行完成任务后，不销毁自己，等待下一次任务：</p>
<p><strong>避免重复创建和销毁线程，造成性能浪费</strong></p>
<p>创建线程池：</p>
<pre><code class="java">ExecutorService threadPool = Executor.newFixedThreadPool(10)  //(corePoolSize = 10)
threadPool.submit(new Callable() &#123;
    public void run()&#123;&#125;
&#125;);
</code></pre>
<p>有新任务的时候</p>
<ul>
<li>如果线程池的线程数量小于容量，则直接创建一个新的线程执行任务。</li>
<li>如果满了，则放在任务队列中。</li>
</ul>
<p>当线程完成自己的任务的时候，会去任务队列中获取任务，如果没有任务，会阻塞，不会销毁。</p>
<h4 id="4-4-2-线程池的核心配置参数"><a href="#4-4-2-线程池的核心配置参数" class="headerlink" title="4.4.2. 线程池的核心配置参数"></a>4.4.2. 线程池的核心配置参数</h4><p>代表线程池的类是ThreadPoolExecutor</p>
<pre><code class="java">return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;())
</code></pre>
<ul>
<li><code>corePoolSize：3</code><ul>
<li>一般最大线程数只有3</li>
</ul>
</li>
<li><code>maximumPoolSize：200</code><ul>
<li>当任务队列满了，可以最多额外创建到200个，执行任务并从任务队列获取任务</li>
</ul>
</li>
<li><code>keepAliveTime：60s</code><ul>
<li>任务队列空了60s后，额外线程自动会销毁掉</li>
</ul>
</li>
<li><code>new ArrayBlockingQueue&lt;Runnable&gt;(200)</code><ul>
<li>任务队列</li>
</ul>
</li>
</ul>
<p>如果额外线程也满了，会报异常。可以自定义RejectedExecutionHandler策略来应对这种情况：持久化被reject的任务，等负载低了再加载执行。</p>
<h4 id="4-4-3-如果在线程池中使用无界阻塞队列会发生什么问题"><a href="#4-4-3-如果在线程池中使用无界阻塞队列会发生什么问题" class="headerlink" title="4.4.3. 如果在线程池中使用无界阻塞队列会发生什么问题"></a>4.4.3. 如果在线程池中使用无界阻塞队列会发生什么问题</h4><p><strong>面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升</strong></p>
<p>调用超时，队列变得越来越大，内存会飙升，可能会导致OOM。</p>
<h4 id="4-4-4-线程池队列满了之后，会发生什么"><a href="#4-4-4-线程池队列满了之后，会发生什么" class="headerlink" title="4.4.4. 线程池队列满了之后，会发生什么"></a>4.4.4. 线程池队列满了之后，会发生什么</h4><ul>
<li>如果给maximumPoolSize设置太大，可能会导致系统崩溃。因为线程会占用一定内存，也会增加cpu负载。</li>
<li>如果给maximumPoolSize设置太小，可能会导致任务reject。</li>
</ul>
<h4 id="4-4-5-如果机器突然宕机，线程池的阻塞队列的任务怎么办"><a href="#4-4-5-如果机器突然宕机，线程池的阻塞队列的任务怎么办" class="headerlink" title="4.4.5. 如果机器突然宕机，线程池的阻塞队列的任务怎么办"></a>4.4.5. 如果机器突然宕机，线程池的阻塞队列的任务怎么办</h4><p><strong>都会丢失</strong></p>
<p>解决办法：在数据库对任务信息进行持久化。</p>
<h3 id="4-5-ThreadLocal"><a href="#4-5-ThreadLocal" class="headerlink" title="4.5. ThreadLocal"></a>4.5. ThreadLocal</h3><p>主要解决的问题：让每个线程绑定自己的值，防止竞争</p>
<p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<h4 id="4-5-1-内存泄漏问题"><a href="#4-5-1-内存泄漏问题" class="headerlink" title="4.5.1. 内存泄漏问题"></a>4.5.1. 内存泄漏问题</h4><p>ThreadLocalMap 使用的key是对ThreadLocal的弱引用，value是强引用。垃圾回收的时候会回收弱引用对象，那么key可能会被回收，导致Map的key为null。如果我们不操作，value则无法被回收</p>
<p>ThreadLocalMap提供的方法：set get remove 都会清楚key为null 的记录。用完ThreadLocal之后最好进行remove()</p>
<h3 id="4-6-Future类"><a href="#4-6-Future类" class="headerlink" title="4.6. Future类"></a>4.6. Future类</h3><p>异步思想的典型运用。</p>
<p>耗时的任务交给future类实现，先执行其他步骤，等到我们需要的时候再通过future类获取。</p>
<pre><code class="java">// V 代表了Future执行的任务返回值的类型
public interface Future&lt;V&gt; &#123;
    // 取消任务执行
    // 成功取消返回 true，否则返回 false
    boolean cancel(boolean mayInterruptIfRunning);
    // 判断任务是否被取消
    boolean isCancelled();
    // 判断任务是否已经执行完成
    boolean isDone();
    // 获取任务执行结果
    V get() throws InterruptedException, ExecutionException;
    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutExceptio
&#125;
</code></pre>
<h2 id="5-Java-IO"><a href="#5-Java-IO" class="headerlink" title="5. Java IO"></a>5. Java IO</h2><p>InputStream&#x2F;Reader：输入流基类，前者是字节输入流，后者是字符输入流</p>
<p>OutputStream&#x2F;Writer：输出流基类，前者是字节输出流，后者是字符输出流</p>
<h3 id="5-1-InputStream"><a href="#5-1-InputStream" class="headerlink" title="5.1. InputStream"></a>5.1. InputStream</h3><p>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>
<h4 id="5-1-1-常用方法"><a href="#5-1-1-常用方法" class="headerlink" title="5.1.1. 常用方法"></a>5.1.1. 常用方法</h4><ul>
<li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
<li><code>available()</code>：返回输入流中可以读取的字节数。</li>
<li><code>close()</code>：关闭输入流释放相关的系统资源。</li>
</ul>
<p>JDK1.9之后添加了：</p>
<ul>
<li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。（实用）</li>
<li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<h4 id="5-1-2-FileInputStream"><a href="#5-1-2-FileInputStream" class="headerlink" title="5.1.2. FileInputStream"></a>5.1.2. FileInputStream</h4><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
<pre><code class="java">try (InputStream fis = new FileInputStream(&quot;input.txt&quot;)) &#123;
    System.out.println(&quot;Number of remaining bytes:&quot;
            + fis.available());
    int content;
    long skip = fis.skip(2);
    System.out.println(&quot;The actual number of bytes skipped:&quot; + skip);
    System.out.print(&quot;The content read from file:&quot;);
    while ((content = fis.read()) != -1) &#123;
        System.out.print((char) content);
    &#125;
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
</code></pre>
<p>一般我们是不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流，后文会讲到）来使用。</p>
<pre><code class="java">// 新建一个 BufferedInputStream 对象
BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;input.txt&quot;));
// 读取文件的内容并复制到 String 对象中
String result = new String(bufferedInputStream.readAllBytes());
System.out.println(result);
</code></pre>
<h4 id="5-1-3-DataInputStream"><a href="#5-1-3-DataInputStream" class="headerlink" title="5.1.3. DataInputStream"></a>5.1.3. DataInputStream</h4><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p>
<pre><code class="java">FileInputStream fileInputStream = new FileInputStream(&quot;input.txt&quot;);
//必须将fileInputStream作为构造参数才能使用
DataInputStream dataInputStream = new DataInputStream(fileInputStream);
//可以读取任意具体的类型数据
dataInputStream.readBoolean();
dataInputStream.readInt();
dataInputStream.readUTF();
</code></pre>
<h4 id="5-1-4-ObjectInputStream"><a href="#5-1-4-ObjectInputStream" class="headerlink" title="5.1.4. ObjectInputStream"></a>5.1.4. ObjectInputStream</h4><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p>
<pre><code class="java">ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;object.data&quot;));
MyClass object = (MyClass) input.readObject();
input.close();
</code></pre>
<p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p>
<h3 id="5-2-OutPutStream"><a href="#5-2-OutPutStream" class="headerlink" title="5.2. OutPutStream"></a>5.2. OutPutStream</h3><p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类</p>
<h4 id="5-2-1-常用方法"><a href="#5-2-1-常用方法" class="headerlink" title="5.2.1. 常用方法"></a>5.2.1. 常用方法</h4><ul>
<li><code>write(int b)</code>：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code>：关闭输出流释放相关的系统资源。</li>
</ul>
<h4 id="5-2-2-FileOutputStream"><a href="#5-2-2-FileOutputStream" class="headerlink" title="5.2.2. FileOutputStream"></a>5.2.2. FileOutputStream</h4><p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<pre><code class="java">try (FileOutputStream output = new FileOutputStream(&quot;output.txt&quot;)) &#123;
    byte[] array = &quot;JavaGuide&quot;.getBytes();
    output.write(array);
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
</code></pre>
<p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code></p>
<pre><code class="java">FileOutputStream fileOutputStream = new FileOutputStream(&quot;output.txt&quot;);
BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream)
</code></pre>
<h4 id="5-2-3-DataOutputStream"><a href="#5-2-3-DataOutputStream" class="headerlink" title="5.2.3. DataOutputStream"></a>5.2.3. DataOutputStream</h4><p><strong><code>DataOutputStream</code></strong> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</p>
<pre><code class="java">// 输出流
FileOutputStream fileOutputStream = new FileOutputStream(&quot;out.txt&quot;);
DataOutputStream dataOutputStream = new DataOutputStream(fileOutputStream);
// 输出任意数据类型
dataOutputStream.writeBoolean(true);
dataOutputStream.writeByte(1);
</code></pre>
<h4 id="5-2-4-ObjectInputStream"><a href="#5-2-4-ObjectInputStream" class="headerlink" title="5.2.4. ObjectInputStream"></a>5.2.4. ObjectInputStream</h4><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<code>ObjectInputStream</code>,反序列化），<code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)</p>
<pre><code class="java">ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;file.txt&quot;)
Person person = new Person(&quot;Guide哥&quot;, &quot;JavaGuide作者&quot;);
output.writeObject(person);
</code></pre>
<h3 id="5-3-Reader"><a href="#5-3-Reader" class="headerlink" title="5.3. Reader"></a>5.3. Reader</h3><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类</p>
<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>
<h4 id="5-3-1-常用方法"><a href="#5-3-1-常用方法" class="headerlink" title="5.3.1. 常用方法"></a>5.3.1. 常用方法</h4><ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>
<li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
<h4 id="5-3-2-InputStreamReader-FileReader"><a href="#5-3-2-InputStreamReader-FileReader" class="headerlink" title="5.3.2. InputStreamReader FileReader"></a>5.3.2. InputStreamReader FileReader</h4><p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>
<pre><code class="java">try (FileReader fileReader = new FileReader(&quot;input.txt&quot;);) &#123;
    int content;
    long skip = fileReader.skip(3);
    System.out.println(&quot;The actual number of bytes skipped:&quot; + skip);
    System.out.print(&quot;The content read from file:&quot;);
    while ((content = fileReader.read()) != -1) &#123;
        System.out.print((char) content);
    &#125;
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
</code></pre>
<h3 id="5-4-Writer"><a href="#5-4-Writer" class="headerlink" title="5.4. Writer"></a>5.4. Writer</h3><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>
<h4 id="5-4-1-常用方法"><a href="#5-4-1-常用方法" class="headerlink" title="5.4.1. 常用方法"></a>5.4.1. 常用方法</h4><ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
<h4 id="5-4-2-OutputStreamWriter-FileWriter"><a href="#5-4-2-OutputStreamWriter-FileWriter" class="headerlink" title="5.4.2. OutputStreamWriter FileWriter"></a>5.4.2. OutputStreamWriter FileWriter</h4><p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p>
<pre><code class="java">try (Writer output = new FileWriter(&quot;output.txt&quot;)) &#123;
    output.write(&quot;你好，我是Guide。&quot;);
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
</code></pre>
<h3 id="5-5-字符缓冲流BufferedInputStream-BufferedOutputStream"><a href="#5-5-字符缓冲流BufferedInputStream-BufferedOutputStream" class="headerlink" title="5.5. 字符缓冲流BufferedInputStream BufferedOutputStream"></a>5.5. 字符缓冲流BufferedInputStream BufferedOutputStream</h3><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>
<p>默认大小8M，可显式定义</p>
<h3 id="5-6-打印流-PrintStream"><a href="#5-6-打印流-PrintStream" class="headerlink" title="5.6. 打印流 PrintStream"></a>5.6. 打印流 PrintStream</h3><p>System.out就是一个PrintStream对象，print调用了write方法</p>
<p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p>
<h3 id="5-7-随机访问流-RandomAccessFile"><a href="#5-7-随机访问流-RandomAccessFile" class="headerlink" title="5.7. 随机访问流 RandomAccessFile"></a>5.7. 随机访问流 RandomAccessFile</h3><p>可以访问到文件的任意字节。</p>
<p>适用于断点重传。</p>
<h2 id="6-谈谈对Java内存模型的理解"><a href="#6-谈谈对Java内存模型的理解" class="headerlink" title="6. 谈谈对Java内存模型的理解"></a>6. 谈谈对Java内存模型的理解</h2><pre><code class="java">public class HelloWorld &#123;
    private int data;
    public void increment()&#123;
        data++;
    &#125;
&#125;
HelloWorld helloWorld = new HelloWorld(); //对象存放在堆内存，包含对象中的实例变量
//线程1
new Thread()&#123;
    public void run()&#123;
        helloWorld.increment();
    &#125;
&#125;.start()
//线程2
new Thread()&#123;
    public void run()&#123;
        helloWorld.increment();
    &#125;
&#125;.start()
   
</code></pre>
<p>常量：主存（内存）</p>
<p>线程的工作内存：cpu缓存</p>
<p>常量操作：read load use assign store write</p>
<img src="http://gohoy.top/i/2023/07/31/ui6jyh-1.png" alt="image-20230731165920298" style="zoom: 80%;" />

<h3 id="6-1-可见性、原子性、有序性"><a href="#6-1-可见性、原子性、有序性" class="headerlink" title="6.1. 可见性、原子性、有序性"></a>6.1. 可见性、原子性、有序性</h3><ul>
<li>可见性<ul>
<li>没有可见性：线程1更新了数据，但是线程2看到的还是工作内存中旧的数据</li>
<li>有可见性：数据更新之后，线程1会强制使线程2重新读取修改后的数据。</li>
</ul>
</li>
<li>原子性<ul>
<li>一次只有一个线程进入临界区。data++必须是独立执行的。</li>
</ul>
</li>
<li>有序性<ul>
<li>在任务需要的资源准备完全之后，执行该线程任务。</li>
</ul>
</li>
</ul>
<h3 id="6-2-从底层角度聊volatile关键字原理"><a href="#6-2-从底层角度聊volatile关键字原理" class="headerlink" title="6.2. 从底层角度聊volatile关键字原理"></a>6.2. 从底层角度聊volatile关键字原理</h3><p>volatile：用来解决<strong>可见性和有序性</strong>，对原子性的保证很有限。（对64位的long型有一定原子性保证）</p>
<ul>
<li>实现可见性<ul>
<li><strong>当加上volatile的变量改变时，会使其他线程工作内存的过期变量失效。</strong></li>
</ul>
</li>
<li>保证有序性<ul>
<li>保证写在读之前</li>
</ul>
</li>
</ul>
<h3 id="6-3-指令重排和happens-before原则"><a href="#6-3-指令重排和happens-before原则" class="headerlink" title="6.3. 指令重排和happens-before原则"></a>6.3. 指令重排和happens-before原则</h3><p>指令重排有可能导致有序性失效。</p>
<p>happens-before原则：</p>
<ul>
<li>线程内按照代码顺序，写在前面的代码先行发生在卸载后面的代码。</li>
<li>锁定操作：对锁的unlock操作先行发生在lock操作</li>
<li>volatile变量原则：写操作在读操作之前</li>
<li>传递原则：A先于B，B先于C，则A先于C</li>
<li>线程启动原则：线程的启动thread.star()先于线程中的其他操作。还有interrupt</li>
<li>线程终结原则：线程的所有操作都先于线程的终止检测，使用thread.jion()结束。</li>
<li>对象终结原则：一个对象的初始化完成在finalize()方法之前。</li>
</ul>
<h3 id="6-4-volatile底层如何基于内存屏障保证可见性和有序性"><a href="#6-4-volatile底层如何基于内存屏障保证可见性和有序性" class="headerlink" title="6.4. volatile底层如何基于内存屏障保证可见性和有序性"></a>6.4. volatile底层如何基于内存屏障保证可见性和有序性</h3><p>对volatile的值的操作代码前后加上内存屏障。</p>
<p>内存屏障：禁止重排序</p>
<h2 id="7-Spring"><a href="#7-Spring" class="headerlink" title="7. Spring"></a>7. Spring</h2><h3 id="7-1-Spring的IOC"><a href="#7-1-Spring的IOC" class="headerlink" title="7.1. Spring的IOC"></a>7.1. Spring的IOC</h3><p>如果没有IOC：tomcat+servlet：tomcat 监听端口来将请求转发给servlet来处理，耦合严重，需要变动时，修改很麻烦。</p>
<p>IOC：<strong>依赖注入，控制反转，容器根据xml配置或者注解来对bean对象之间的引用关系进行依赖注入</strong></p>
<p>底层核心技术：反射。根据类来自动构建对应的对象。</p>
<p>类与类彻底解耦。</p>
<p><img src="http://gohoy.top/i/2023/08/01/njxvd8-1.png" alt="image-20230801142412643"></p>
<h3 id="7-2-Spring的AOP"><a href="#7-2-Spring的AOP" class="headerlink" title="7.2. Spring的AOP"></a>7.2. Spring的AOP</h3><p>MySQL：事务：一次开启一个事务，其中进行多次增删改查。如果有一条失败了，会回滚事务，把这个事务中所有的sql语句都恢复。</p>
<p>AOP:做一个切面Aspect，给所有类似servicexxx代码之前都会开启一个事务，在这些方法运行完毕之后，根据是否抛出异常，去回滚或者提交事务。</p>
<p>核心技术：动态代理</p>
<p><strong>Spring会给正在运行的类生成动态代理类，包含我们写的类。然后在代理类中给逻辑前后加上事务。</strong></p>
<p>如何限定AOP。</p>
<p>TODO</p>
<h3 id="7-3-了解过cglib动态代理吗，他和jdk动态代理的区别是什么"><a href="#7-3-了解过cglib动态代理吗，他和jdk动态代理的区别是什么" class="headerlink" title="7.3. 了解过cglib动态代理吗，他和jdk动态代理的区别是什么"></a>7.3. 了解过cglib动态代理吗，他和jdk动态代理的区别是什么</h3><p>jdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。</p>
<p>没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。</p>
<h3 id="7-4-spring事务的实现原理是什么，事务传播机制是什么"><a href="#7-4-spring事务的实现原理是什么，事务传播机制是什么" class="headerlink" title="7.4. spring事务的实现原理是什么，事务传播机制是什么"></a>7.4. spring事务的实现原理是什么，事务传播机制是什么</h3><p>不同事务之间不互相影响</p>
<p>@Transactional(propagation &#x3D; Propagation.REQUIRED)会开启一个事务</p>
<ul>
<li>Propagation_REQUIRED：如果当前没有事务，创建一个事务，多个调用加入到一个事务中。</li>
<li>Propagation_SUPPORT：之前有事务则加入，没有则不开启。</li>
<li>Propagation_MANDATORY：有事务加入，没有则报错。</li>
<li>Propagation_RESQUIRES_NEW：强制开启一个新事务。</li>
<li>Propagation_NOT_SUPPORTED：不使用事务，有事务会挂起</li>
<li>Propagation_NEVER：不允许使用事务，有事务会报错</li>
<li>Propagation_NESTED：嵌套事务，外层事务回滚会导致内存事务也回滚，内层不影响外层。</li>
</ul>
<h3 id="7-5-Springboot-的核心架构"><a href="#7-5-Springboot-的核心架构" class="headerlink" title="7.5. Springboot 的核心架构"></a>7.5. Springboot 的核心架构</h3><p>自动装配依赖。不需要像spring一样自己配置xml文件，引入jar包。减少了配置。</p>
<h3 id="7-6-Spring-核心源码"><a href="#7-6-Spring-核心源码" class="headerlink" title="7.6. Spring 核心源码"></a>7.6. Spring 核心源码</h3><p>Spring bean 生命周期：</p>
<ul>
<li>创建bean<ul>
<li>实例化一个bean</li>
<li>依赖注入<ul>
<li>把这个bean的依赖的bean实例化，也进行依赖注入。注入方法：构造函数，setter方法。</li>
</ul>
</li>
<li>处理Aware接口<ul>
<li>如果这个bean实现了Aware相关的接口，Spring容器会把自己的信息注入给bean中。</li>
</ul>
</li>
<li>BeanPostProcesser<ul>
<li>在bean实例初始化之前和之后可以执行的方法。</li>
</ul>
</li>
<li>init初始化方法</li>
</ul>
</li>
<li>销毁<ul>
<li>DisposableBean接口，会调用这个接口实现的destroy方法</li>
<li>最后，如果配置了destroy-method方法，会调用这个方法</li>
</ul>
</li>
</ul>
<h3 id="7-7-Spring中的设计模式"><a href="#7-7-Spring中的设计模式" class="headerlink" title="7.7. Spring中的设计模式"></a>7.7. Spring中的设计模式</h3><p>工厂，单例，代理</p>
<p>工厂模式：使用工厂类来创建类。</p>
<p>单例模式：每个bean在系统运行期间只会创建一个实例对象。</p>
<p>代理模式：AOP</p>
<h3 id="7-8-SpringMVC架构"><a href="#7-8-SpringMVC架构" class="headerlink" title="7.8. SpringMVC架构"></a>7.8. SpringMVC架构</h3><ul>
<li>tomcat 监听端口，将请求转发给SpringMVC的DispathcherServlet</li>
<li>然后SpringMVC再根据url将请求转发给对应的controller</li>
<li>返回json给前端，前端符合渲染</li>
</ul>
<h3 id="7-9-SpringCloud核心架构"><a href="#7-9-SpringCloud核心架构" class="headerlink" title="7.9. SpringCloud核心架构"></a>7.9. SpringCloud核心架构</h3><p>这些框架</p>
<h2 id="8-JVM"><a href="#8-JVM" class="headerlink" title="8. JVM"></a>8. JVM</h2><h3 id="8-1-JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进"><a href="#8-1-JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进" class="headerlink" title="8.1. JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进"></a>8.1. JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进</h3><ul>
<li>栈内存：每个线程独有</li>
<li>堆内存：存放对象、实例</li>
<li>永久代区域：我们写的类</li>
</ul>
<p>Java8以后永久代变成metaspace</p>
<p>常量区放在了堆里面</p>
<h3 id="8-2-JVM如何运行起来的，如何创建各种对象"><a href="#8-2-JVM如何运行起来的，如何创建各种对象" class="headerlink" title="8.2. JVM如何运行起来的，如何创建各种对象"></a>8.2. JVM如何运行起来的，如何创建各种对象</h3><p><strong>线程执行main函数同时创建对象</strong></p>
<p>Spring容器创建一些bean对象</p>
<p>把执行的方法和局部变量放在栈帧。</p>
<h3 id="8-3-JVM什么时候会触发垃圾回收"><a href="#8-3-JVM什么时候会触发垃圾回收" class="headerlink" title="8.3. JVM什么时候会触发垃圾回收"></a>8.3. JVM什么时候会触发垃圾回收</h3><p>内存分代：年轻代（eden：s1： s2，  8：1：1 ）和老年代</p>
<p>年轻代和老年代统称为堆</p>
<p>新生成的对象实例存放在年轻代。</p>
<ul>
<li>ygc：Eden区满了。进行youngGC<ul>
<li>没有引用的对象（类）被回收</li>
</ul>
</li>
</ul>
<p>年轻代垃圾回收算法：</p>
<ul>
<li>复制算法：因为年轻代中大多数都是垃圾对象，所以把存活对象复制到s1中，一键全部清除Eden区。<ul>
<li>把s1和Eden中的存活对象复制到s2，把s1和Eden区全部清除</li>
</ul>
</li>
</ul>
<h3 id="8-4-什么时候对象会转移到老年代"><a href="#8-4-什么时候对象会转移到老年代" class="headerlink" title="8.4. 什么时候对象会转移到老年代"></a>8.4. 什么时候对象会转移到老年代</h3><p>如果存活了多次垃圾回收过程，就会转移到老年代</p>
<p>如果s区放不下，会把一些存活的对象直接放到老年代中。</p>
<p>对于大对象会直接放到老年代中，防止ygc反复复制大对象。</p>
<h3 id="8-5-常用的垃圾回收器，老年代如何回收"><a href="#8-5-常用的垃圾回收器，老年代如何回收" class="headerlink" title="8.5. 常用的垃圾回收器，老年代如何回收"></a>8.5. 常用的垃圾回收器，老年代如何回收</h3><p>老年代中大多数是长期存活的对象，所以使用标记-清理方法：把所有存活的对象压缩到连续的位置，然后统一清理，可以防止内存碎片问题。</p>
<p>常用的垃圾回收器：</p>
<ul>
<li>CMS+parnew jdk8-jdk9</li>
<li>g1 jdk11 </li>
<li>ZGC</li>
</ul>
<h3 id="8-6-生产环境如何设置jvm参数的，如何检查jvm的运行情况"><a href="#8-6-生产环境如何设置jvm参数的，如何检查jvm的运行情况" class="headerlink" title="8.6. 生产环境如何设置jvm参数的，如何检查jvm的运行情况"></a>8.6. 生产环境如何设置jvm参数的，如何检查jvm的运行情况</h3><p>tomcat的配置脚本，catalina脚本设置。</p>
<p>如果使用jar启动，再java命令后直接加上参数</p>
<p>参数：</p>
<ul>
<li>内存区域大小的分配：<ul>
<li>栈大小</li>
<li>metaspace大小</li>
<li>eden  survivor</li>
<li>堆大小</li>
<li>年轻代、老年代</li>
</ul>
</li>
<li>垃圾回收器<ul>
<li>年轻代和老年代用了什么回收器</li>
<li>是否有特殊参数，作用是什么</li>
</ul>
</li>
</ul>
<p>jstat压测，QPS,接口性能</p>
<h3 id="8-7-JVM-GC优化"><a href="#8-7-JVM-GC优化" class="headerlink" title="8.7. JVM GC优化"></a>8.7. JVM GC优化</h3><p>自己动手进行压测，调试一下</p>
<h3 id="8-8-发生OOM之后，应该如何排查和处理线上系统的OOM问题"><a href="#8-8-发生OOM之后，应该如何排查和处理线上系统的OOM问题" class="headerlink" title="8.8. 发生OOM之后，应该如何排查和处理线上系统的OOM问题"></a>8.8. 发生OOM之后，应该如何排查和处理线上系统的OOM问题</h3><p>在jvm设置参数，发生oom之后保存快照。</p>
<p>找出占用内存最大的对象和创建它的代码，进行调优。</p>
<h2 id="9-网络"><a href="#9-网络" class="headerlink" title="9. 网络"></a>9. 网络</h2><h3 id="9-1-TCP-IP的四层模型和七层网络模型"><a href="#9-1-TCP-IP的四层模型和七层网络模型" class="headerlink" title="9.1. TCP&#x2F;IP的四层模型和七层网络模型"></a>9.1. TCP&#x2F;IP的四层模型和七层网络模型</h3><p>TCP&#x2F;IP四层：数据链路层、网络层、传输层、应用层</p>
<ul>
<li>物理层：硬件部分</li>
<li>数据链路层：将0&#x2F;1信号分组，确定来源去向<ul>
<li>以太网协议：一组信号是一个网络帧。每帧有两个部分：表头和数据，表头保存说明性的东西，比如发送者，接收者，数据类型等。通过网卡来发送接收数据，mac地址是网卡的id。</li>
<li>mac：前6个16进制是厂商编号，后6个编号是网卡流水号。</li>
</ul>
</li>
<li>网络层：<ul>
<li>IP协议</li>
<li>判断是不是一个子网：使用ip的二进制和子网掩码进行与运算，看结果前三个部分如果是一样的就是子网。</li>
<li>不在一个子网需要一个路由器，路由器判断数据包的目标mac是不是自己的子网内的mac，是则转发。</li>
<li>ARP cache 会让每一个电脑都缓存到子网中所以电脑的ip和mac对应关系。</li>
<li>路由器就可以看做是一个网关</li>
</ul>
</li>
<li>传输层TCP协议：仅仅规定了基于端口的点对点通信协议，包含如何建立连接，读取和发送信息。要基于TCP 开发，实际上是使用socket开发。</li>
<li>应用层：最常见的是http</li>
</ul>
<p>OSI七层：物理层、会话层、表示层 + 四层模型</p>
<p>DNS：domain name server ，先通过dns服务器把域名翻译成IP。</p>
<h3 id="9-2-浏览器访问baidu-com会发生什么"><a href="#9-2-浏览器访问baidu-com会发生什么" class="headerlink" title="9.2. 浏览器访问baidu.com会发生什么"></a>9.2. 浏览器访问baidu.com会发生什么</h3><ul>
<li>域名解析为IP</li>
<li>把请求打包成http包</li>
<li>把http数据包包装成tcp数据包，tcp数据头包含接收者和发送者的端口号</li>
<li>然后把全部数据包包装到ip数据包，ip数据头中包含发送者和接收者的ip</li>
<li>然后以太网会把这个数据包封装到以太网数据包中，加上以太网头，其中包含有发送者和接收者的网卡mac地址。<ul>
<li>以太网一次传输字节有限，可能需要切割为多个包。</li>
<li>根据IP头序号来合成一个包。</li>
</ul>
</li>
<li>然后通过多个路由转发到百度的子网中。</li>
</ul>
<h3 id="9-3-TCP三次握手和四次挥手的流程，为什么不是五次或者两次？"><a href="#9-3-TCP三次握手和四次挥手的流程，为什么不是五次或者两次？" class="headerlink" title="9.3. TCP三次握手和四次挥手的流程，为什么不是五次或者两次？"></a>9.3. TCP三次握手和四次挥手的流程，为什么不是五次或者两次？</h3><ul>
<li>建立连接的三次握手：<ul>
<li>客户端发送syn（同步），表示自己进入了syn_send状态</li>
<li>服务端恢复syn+ack（确认）表示确认收到同步请求，并且自己进入syn_recevie状态</li>
<li>客户端发送ack，表示确认建立连接。当服务端接收到这个包的时候，连接正式建立</li>
</ul>
</li>
<li>为什么不是两次握手<ul>
<li>如果网络问题，遇到不想要的连接，三次连接可以让客户端发送给服务器复位信息，释放资源</li>
</ul>
</li>
<li>结束连接的四次挥手：<ul>
<li>客户端发送FIN（结束）</li>
<li>服务端发送ACK（收到），这段时间有可能传输还没有完全完毕，等待全部完毕后再发送FIN。</li>
<li>服务端发送FIN（结束）</li>
<li>客户端发送ACK（收到）：服务端收到这个请求后立刻关闭，客户端会等待一段时间，保证服务端确实接收到这个包</li>
</ul>
</li>
</ul>
<p> 2 3次挥手好像在某些情况可以合并？</p>
<h3 id="9-4-说一下http长连接的原理"><a href="#9-4-说一下http长连接的原理" class="headerlink" title="9.4. 说一下http长连接的原理"></a>9.4. 说一下http长连接的原理</h3><p><strong>http本身没有长连接，都是tcp的长连接和短链接</strong></p>
<p>http协议规范：请求头，请求体什么的</p>
<p>http1.0 都是短链接，一次请求后直接断开tcp连接，需要指定keep-alive才能建立长连接</p>
<p>http1.1 默认是长连接</p>
<p>http2.0支持多路复用，一个tcp可以并行发送多个请求以及接收响应。</p>
<p>http3.0 QUIC 建立在udp之上。</p>
<h3 id="9-5-https-http-ssl-tsl"><a href="#9-5-https-http-ssl-tsl" class="headerlink" title="9.5. https http+ssl&#x2F;tsl"></a>9.5. https http+ssl&#x2F;tsl</h3><p>使用证书加密</p>
<ul>
<li>非对称加密：rsa<ul>
<li>网站给浏览器发送证书（由权威机构颁发），浏览器验证合法性</li>
<li>浏览器生成随机密码，用随机密码加密随机密码的hash，并且用证书的公钥加密这个随机密码，</li>
<li>网站用证书的私钥解密这个随机面膜，再用随机密码解密得到hash，计算自己得到的密码的hash进行对比，如果完全相同，则可以使用</li>
<li>之后用这个随机密码来实现加密通信。</li>
</ul>
</li>
</ul>
<h2 id="10-MySQL"><a href="#10-MySQL" class="headerlink" title="10. MySQL"></a>10. MySQL</h2><h3 id="10-1-引擎：mysiam-innodb"><a href="#10-1-引擎：mysiam-innodb" class="headerlink" title="10.1. 引擎：mysiam innodb"></a>10.1. 引擎：mysiam innodb</h3><ul>
<li>mysiam：不支持事务，不支持外键约束。索引和数据文件分开，可以在内存缓存更多索引，查询性能会更好，适用于少量插入，大量查询<ul>
<li>hadoop报表系统，用mysql mysiam比较适合，但是数据量太大超过500w以上就也不能用mysql了。</li>
</ul>
</li>
<li>innodb（默认）：支持事务，外键约束，高并发，高可用，大数据量</li>
</ul>
<h3 id="10-2-Mysql索引原理和数据结构。"><a href="#10-2-Mysql索引原理和数据结构。" class="headerlink" title="10.2. Mysql索引原理和数据结构。"></a>10.2. Mysql索引原理和数据结构。</h3><p>索引：默认b+树</p>
<ul>
<li>b-树<ul>
<li>每个节点都存储对应的data</li>
</ul>
</li>
<li>b+树<ul>
<li>只有叶子节点存储对应的data</li>
</ul>
</li>
</ul>
<p>Mysiam的索引：叶子节点存储的是索引的物理地址。然后用物理地址去数据文件找数据。</p>
<p>Innodb的索引：表要求必须要有主键，默认会为主键建立一个索引，节点data包含所有数据（一个记录，整行），叫做聚簇索引。如果你使用name来找数据，那么从name索引中找到的data是主键（id），再用id从聚簇索引找data。</p>
<h3 id="10-3-索引的使用规则"><a href="#10-3-索引的使用规则" class="headerlink" title="10.3. 索引的使用规则"></a>10.3. 索引的使用规则</h3><p>怎么建立索引？</p>
<p><strong>最左前缀匹配原则：</strong></p>
<p>创建联合索引：create index(shop_id,product_id,gmt_create)</p>
<p>如果你使用 shop_id 和 gmt_create来查找，那么不会直接通过这个联合索引查找，而是通过使用shop_id筛选出来一些数据，之后扫描gmt_create字段符合要求过滤。（性能也还行）。</p>
<p><strong>但如果没有最左边的任何字段，就没法用这个索引</strong>，比如直接通过product_id查找，这个是没有用到这个索引的。</p>
<p>范围列匹配，最左前缀范围查找会用索引，之后的不会用索引了。</p>
<p>调用了函数的sql语句不使用索引</p>
<p><strong>建立尽量少的索引，10条以内为佳</strong></p>
<p><strong>尽量选唯一字段进行建立索引</strong>。选择的字段 去重后数量&#x2F;总数量 ，结果要是小，则说明这个索引用处不大。</p>
<h3 id="10-4-事务的几个特点"><a href="#10-4-事务的几个特点" class="headerlink" title="10.4. 事务的几个特点"></a>10.4. 事务的几个特点</h3><p><strong>ACID</strong></p>
<ul>
<li>Atomic：原子性，同时执行的sql要么一起成功，要么一起失败</li>
<li>Consistency：一致性，事务之前前后数据都应该是正确的</li>
<li>Isolation：隔离性，多个事务之间不互相干扰</li>
<li>Durability：持久性</li>
</ul>
<h3 id="10-5-隔离级别"><a href="#10-5-隔离级别" class="headerlink" title="10.5. 隔离级别"></a>10.5. 隔离级别</h3><ul>
<li>读未提交：事务A读取到事务B还没有提交的数据</li>
<li>读已提交：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到不一样的数据。（不可重复读）</li>
<li>可重复读：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到的还是事务A最开始读取到的数据。（可重复读）</li>
<li>幻读（不是隔离级别）：事务A查询所有数据，准备插入一一条数据，事务B插入了一行数据，事务B提交插入。事务A想要插入数据，发现这个数据已经存在（被事务B插入）。</li>
<li>串行化（为了解决幻读）：事务A查询所有数据，事务B想要插入一行数据会被拒绝。事务A提交后，事务B才能进行插入数据。</li>
</ul>
<p><strong>MySQL默认级别：可重复读。</strong></p>
<p><strong>实现可重复读的机制</strong>：MVCC机制 multi-version concurrency control</p>
<ul>
<li><p>事务id是全局唯一且递增的，</p>
</li>
<li><p>查询事务只会找比自己事务id小的 创建事务。</p>
<ul>
<li><p>创建事务id&lt;&#x3D;当前事务id</p>
</li>
<li><p>当前事务id&lt;删除事务id</p>
</li>
</ul>
</li>
<li><p>不同事务修改某行数据，会多出来一行，id相同。</p>
</li>
</ul>
<h3 id="10-6-数据库锁"><a href="#10-6-数据库锁" class="headerlink" title="10.6. 数据库锁"></a>10.6. 数据库锁</h3><p><strong>自动加锁</strong></p>
<p>表锁 行锁 页锁</p>
<ul>
<li>myisam会加表锁。锁表的时候查询会报504</li>
</ul>
<p>行锁：innodb：共享锁（s）和排他锁（x）</p>
<ul>
<li>共享锁和排他锁不能同时加</li>
<li>select 不加锁因为MVCC有快照，增删改会加一个行锁排他锁。</li>
</ul>
<p><strong>手动加锁</strong></p>
<p>加共享锁：select * from table where id &#x3D; 1 lock in share mode</p>
<p>加排他锁：select * from table where id &#x3D;1 for update</p>
<p><strong>悲观锁</strong>：进行操作都加上排他锁</p>
<p><strong>乐观锁</strong>：加上版本号字段，在事务修改期间如果版本号不同，则这次修改失败，需要重新读取操作。</p>
<p><strong>死锁</strong>：dba查看死锁日志。</p>
<h3 id="10-7-MySQL调优的常用手段"><a href="#10-7-MySQL调优的常用手段" class="headerlink" title="10.7. MySQL调优的常用手段"></a>10.7. MySQL调优的常用手段</h3><ul>
<li>保持sql简单，建议使用单表查询<ul>
<li>优化索引</li>
<li>查看sql的执行计划：explain select * from table</li>
</ul>
</li>
</ul>
<h3 id="10-8-E-R图"><a href="#10-8-E-R图" class="headerlink" title="10.8. E-R图"></a>10.8. E-R图</h3><p>entities-relationship图</p>
<p>关系：操作数是关系，重复行的对应关系（投影）要去掉。剩下的是关系：一对多，一对一，多对多等</p>
<h2 id="11-socket"><a href="#11-socket" class="headerlink" title="11. socket"></a>11. socket</h2><p>直接使用tcp进行通信，就是socket编程</p>
<p>可以认为socket处于传输层。或者是介于传输层和应用层直接。</p>
<p>socket 就是封装了tcp的编程规范</p>
<h2 id="12-进程通信和线程切换"><a href="#12-进程通信和线程切换" class="headerlink" title="12. 进程通信和线程切换"></a>12. 进程通信和线程切换</h2><h3 id="12-1-进程通信"><a href="#12-1-进程通信" class="headerlink" title="12.1. 进程通信"></a>12.1. 进程通信</h3><p>9.1.1管道 pipe</p>
<p>只有父子进程（fork得到的）才能使用这个管道进行通信。</p>
<p>9.1.2命名管道</p>
<p>无亲缘关系的管道可以使用命名管道通信</p>
<p>9.1.3消息队列</p>
<p>9.1.4共享内存</p>
<h3 id="12-2-线程如何切换"><a href="#12-2-线程如何切换" class="headerlink" title="12.2. 线程如何切换"></a>12.2. 线程如何切换</h3><p>时间片轮换</p>
<p>优先级调度等</p>
<h2 id="13-nio，bio，aio都是什么，有什么区别。nio的原理是什么"><a href="#13-nio，bio，aio都是什么，有什么区别。nio的原理是什么" class="headerlink" title="13. nio，bio，aio都是什么，有什么区别。nio的原理是什么"></a>13. nio，bio，aio都是什么，有什么区别。nio的原理是什么</h2><h3 id="13-1-bio通信原理"><a href="#13-1-bio通信原理" class="headerlink" title="13.1. bio通信原理"></a>13.1. bio通信原理</h3><p>服务端使用ServerSocket为每一个客户端建立一个线程用于通信。只要客户端还和服务端有连接，这个线程都要等待。</p>
<p>问题：超过几千客户端就不能够正常运行了</p>
<h3 id="13-2-nio通信原理"><a href="#13-2-nio通信原理" class="headerlink" title="13.2. nio通信原理"></a>13.2. nio通信原理</h3><p>每有一个客户端和服务端建立连接，都会创建一个channel，这些channel都会注册在selector中，这个selector只有一个线程。会不断轮询这些channel。，如果有请求过来，会创建一个线程来处理这个请求。处理完成后这个线程会被销毁。</p>
<p>可以对处理请求的线程创建一个线程池。</p>
<p>在工作线程和channel 直接可以维护一个cache</p>
<p>工作线程从channel 中读取数据，给channel写数据，是同步的</p>
<h3 id="13-3-aio"><a href="#13-3-aio" class="headerlink" title="13.3. aio"></a>13.3. aio</h3><p>对nio有优化：工作进程从channel读数据的时候，会绑定一个buffer，让操作系统来完成读操作，读完了来通知这个线程。</p>
<p>写的时候也是把写的过程交给操作系统。</p>
<h3 id="13-4-同步阻塞、同步非阻塞、异步非阻塞"><a href="#13-4-同步阻塞、同步非阻塞、异步非阻塞" class="headerlink" title="13.4. 同步阻塞、同步非阻塞、异步非阻塞"></a>13.4. 同步阻塞、同步非阻塞、异步非阻塞</h3><p>BIO是同步阻塞，针对的是对磁盘文件的io读写。读写过程中线程阻塞</p>
<p>NIO是同步非阻塞，在操作系统读写数据的时候，线程可以做其他事情，但是也需要不断轮询判断读写完成了没有。</p>
<p>AIO 是异步非阻塞，发起文件读写的操作之后，交给操作系统，操作系统执行完毕之后，会通知这个线程。</p>
<h3 id="13-5-BIO-NIO-AIO-demo代码"><a href="#13-5-BIO-NIO-AIO-demo代码" class="headerlink" title="13.5. BIO NIO AIO demo代码"></a>13.5. BIO NIO AIO demo代码</h3><p>TOREAD</p>
<h2 id="14-线上服务器问题"><a href="#14-线上服务器问题" class="headerlink" title="14. 线上服务器问题"></a>14. 线上服务器问题</h2><h3 id="14-1-线上CPU占用100-，排查步骤："><a href="#14-1-线上CPU占用100-，排查步骤：" class="headerlink" title="14.1. 线上CPU占用100%，排查步骤："></a>14.1. 线上CPU占用100%，排查步骤：</h3><ul>
<li>top -c 输入P ，按照cpu进行排序</li>
<li>top -Hp pid ，可以看到这个进程的负载</li>
<li>把线程pid换成16进制pidhex，如何使用jstack pid | grep pidhex -C5 –color 就可以定位到线程中哪行代码的cpu占用最高。</li>
</ul>
<h3 id="14-2-如果线上进程kill不掉怎么办"><a href="#14-2-如果线上进程kill不掉怎么办" class="headerlink" title="14.2. 如果线上进程kill不掉怎么办"></a>14.2. 如果线上进程kill不掉怎么办</h3><p>ps aux 查看是否有僵尸进程 zombie</p>
<p>ps -ef  | grep 僵尸进程id ，得到父进程id</p>
<p>然后kill 父进程之后kill子进程。</p>
<h3 id="14-3-磁盘马上占满了怎么办"><a href="#14-3-磁盘马上占满了怎么办" class="headerlink" title="14.3. 磁盘马上占满了怎么办"></a>14.3. 磁盘马上占满了怎么办</h3><p>是否是日志占满空间了？</p>
<p>经历：安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志&#x2F;var&#x2F;log&#x2F;pcp&#x2F;pmlogger&#x2F;openEuler1&#x2F;。</p>
<p>关于pcp：</p>
<ul>
<li>Performance Co-Pilot (<code>pcp</code>) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。 	</li>
<li>这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。</li>
</ul>
<p> 	</p>
<p>find &#x2F; -size+100M | xargs ls -lh  找大于100m的文件</p>
<h2 id="15-Java语言特性"><a href="#15-Java语言特性" class="headerlink" title="15. Java语言特性"></a>15. Java语言特性</h2><h3 id="15-1-参数传递"><a href="#15-1-参数传递" class="headerlink" title="15.1. 参数传递"></a>15.1. 参数传递</h3><ul>
<li>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本</li>
</ul>
</li>
<li>想要通过传值来修改原来的值<ul>
<li>通过数组</li>
<li>通过类</li>
<li>或者其他可变的引用类型</li>
</ul>
</li>
<li>不可变的引用类型<ul>
<li>String</li>
<li>Integer</li>
<li>BigDecimal</li>
<li>LocalDate、LocalTime、LocalDateTime、Duration，Period</li>
</ul>
</li>
</ul>
<h3 id="15-2-序列化"><a href="#15-2-序列化" class="headerlink" title="15.2. 序列化"></a>15.2. 序列化</h3><ul>
<li><p>序列化协议属于应用层或者传输层</p>
</li>
<li><p>序列化的对象：实现Serializable 接口的类、实例变量的值、非静态成员变量</p>
</li>
<li><p>serialVersionUID：用来判断对象版本。手动设置这个变量可以解决对象版本兼容问题。</p>
</li>
<li><p>Kryo用来序列化Java代码性能高。</p>
<ul>
<li><pre><code class="java">import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

import java.io.*;

public class KryoSerializationExample &#123;
    public static void main(String[] args) &#123;
        // 创建 Kryo 对象
        Kryo kryo = new Kryo();

        // 创建要序列化的对象
        Person person = new Person(&quot;Alice&quot;, 30);

        // 序列化
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        Output output = new Output(outputStream);
        kryo.writeObject(output, person);
        output.close();

        // 将序列化的数据保存到文件
        try (FileOutputStream fileOutputStream = new FileOutputStream(&quot;person.dat&quot;)) &#123;
            outputStream.writeTo(fileOutputStream);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;

        // 反序列化
        try (FileInputStream fileInputStream = new FileInputStream(&quot;person.dat&quot;)) &#123;
            // 创建 Kryo 输入流
            Input input = new Input(fileInputStream);

            // 从输入流中反序列化对象
            Person deserializedPerson = kryo.readObject(input, Person.class);
            input.close();

            // 使用反序列化后的对象
            System.out.println(&quot;姓名: &quot; + deserializedPerson.getName());
            System.out.println(&quot;年龄: &quot; + deserializedPerson.getAge());
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="15-3-泛型和通配符"><a href="#15-3-泛型和通配符" class="headerlink" title="15.3. 泛型和通配符"></a>15.3. 泛型和通配符</h3><ol>
<li>泛型（Generics）：泛型允许在编译时指定类、接口或方法操作的数据类型，以提供类型安全和代码重用。通过使用泛型，可以在编译时捕获类型错误，并避免在运行时出现类型转换错误。<ul>
<li>定义泛型类：使用 <code>&lt;T&gt;</code> 来表示类型参数，可以在类名后面声明一个泛型类型。例如：<code>class MyClass&lt;T&gt; &#123; ... &#125;</code>。</li>
<li>定义泛型方法：使用 <code>&lt;T&gt;</code> 来表示类型参数，可以在方法返回类型前声明一个泛型类型。例如：<code>&lt;T&gt; T myMethod(T obj) &#123; ... &#125;</code>。</li>
<li>约定<ul>
<li><code>E</code>：表示集合中的元素类型。</li>
<li><code>K</code>：表示映射中的键类型。</li>
<li><code>V</code>：表示映射中的值类型。</li>
<li><code>T</code>：表示任意类型。</li>
<li><code>S</code>、<code>U</code>、<code>V</code>：用于表示第二、第三和第四类型参数。</li>
</ul>
</li>
</ul>
</li>
<li>类型通配符（Wildcard）：类型通配符用问号 <code>?</code> 表示，用于灵活处理不同类型的泛型对象。通配符可以用于泛型类、泛型方法和通配符限定。<ul>
<li>通配符限定上界：<code>? extends Type</code>，表示泛型参数是 Type 类型或其子类。例如：<code>List&lt;? extends Number&gt;</code> 表示一个只能接受 Number 及其子类的 List。</li>
<li>通配符限定下界：<code>? super Type</code>，表示泛型参数是 Type 类型或其父类。例如：<code>List&lt;? super Integer&gt;</code> 表示一个只能接受 Integer 及其父类的 List。</li>
<li>无限制通配符：<code>?</code>，表示可以是任意类型。例如：<code>List&lt;?&gt;</code> 表示一个可以接受任意类型的 List。</li>
</ul>
</li>
</ol>
<h3 id="15-4-反射"><a href="#15-4-反射" class="headerlink" title="15.4. 反射"></a>15.4. 反射</h3><h5 id="15-4-1-1-基本操作"><a href="#15-4-1-1-基本操作" class="headerlink" title="15.4.1.1. 基本操作"></a>15.4.1.1. 基本操作</h5><pre><code class="java">//获取类
Class&lt;?&gt; myClass = MyClass.class;
Class&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);
//获取构造函数
Constructor&lt;?&gt; constructor = myClass.getDeclaredConstructor(parameterTypes);
//创建对象
Object myObject = constructor.newInstance(arguments);
//获取方法
Method method = myClass.getDeclaredMethod(&quot;methodName&quot;, parameterTypes);
//调用方法
method.invoke(myObject, arguments);
//获取字段
Field field = myClass.getDeclaredField(&quot;fieldName&quot;);
//获取字段的值
Object fieldValue = field.get(myObject);
//设置字段的值
field.set(myObject, value);
//对于私有方法或字段，可能需要使用setAccessible(true)来绕过访问限制。
</code></pre>
<h3 id="15-5-代理模式"><a href="#15-5-代理模式" class="headerlink" title="15.5. 代理模式"></a>15.5. 代理模式</h3><h5 id="15-5-1-1-1-静态代理："><a href="#15-5-1-1-1-静态代理：" class="headerlink" title="15.5.1.1. 1.静态代理："></a>15.5.1.1. 1.静态代理：</h5><p>就是把在调用类的前后在执行一些步骤。</p>
<pre><code class="java">public class SmsProxy implements SmsService &#123;

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) &#123;
        this.smsService = smsService;
    &#125;

    @Override
    public String send(String message) &#123;
        //调用方法之前，我们可以添加自己的操作
        System.out.println(&quot;before method send()&quot;);
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println(&quot;after method send()&quot;);
        return null;
    &#125;
&#125;
</code></pre>
<h5 id="15-5-1-2-2-动态代理"><a href="#15-5-1-2-2-动态代理" class="headerlink" title="15.5.1.2. 2.动态代理"></a>15.5.1.2. 2.动态代理</h5><p><strong>2.1JDK代理：在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<pre><code class="java">//调用proxy的方法newProxyInstance
Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new DebugInvocationHandler(target));
//DebugInvocationHandler 是自定义的proxy方法，需要实现InvocationHandler接口的invoke方法，实际上是调用了这里的invoke方法
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
public class DebugInvocationHandler implements InvocationHandler &#123;
    private final Object target;
    public DebugInvocationHandler(Object target) &#123;
        this.target = target;
    &#125;
    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;
        System.out.println(&quot;before Method&quot;+ method.getName());
        Object result = method.invoke(target, objects);
        System.out.println(&quot;after Method&quot;+ method.getName());
        return result;
    &#125;
&#125;
</code></pre>
<p>JDK 动态代理有一个最致命的问题是其<strong>只能代理实现了接口的类</strong>。</p>
<p>为了解决这个问题，我们可以用 CGLIB 动态代理机制。</p>
<p><strong>2.2CGLIB代理</strong></p>
<ul>
<li><p>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</p>
</li>
<li><p>maven依赖：</p>
<ul>
<li><pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;cglib&lt;/groupId&gt;
  &lt;artifactId&gt;cglib&lt;/artifactId&gt;
  &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
<li><pre><code class="java">//代理工厂中生成一个 enhancer对象，这个对象拥有下列属性，其中DebugMethodInterceptor拦截器是自定义的最终执行的方法
public class CglibProxyFactory &#123;
    public static Object getProxy(Class&lt;?&gt; clazz)&#123;
        Enhancer enhancer = new Enhancer();
        enhancer.setClassLoader(clazz.getClassLoader());
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(new DebugMethodInterceptor());
        return enhancer.create();
    &#125;
&#125;
//DebugMethodInterceptor 实现MethodInterceptor接口，重写intercept方法，这个方法相当于前面的invoke
public class DebugMethodInterceptor implements MethodInterceptor &#123;
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
        //调用方法之前，我们可以添加自己的操作
        System.out.println(&quot;before method &quot; + method.getName());
        Object object = methodProxy.invokeSuper(o, objects);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println(&quot;after method &quot; + method.getName());
        return object;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>2.3二者的区别</strong></p>
<p>jdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。</p>
<p>没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。</p>
<h3 id="15-6-BigDecimal常见方法"><a href="#15-6-BigDecimal常见方法" class="headerlink" title="15.6. BigDecimal常见方法"></a>15.6. BigDecimal常见方法</h3><p>我们在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>
<p><strong>使用BigDecimal(double val)会丢失精度</strong></p>
<p>方法：</p>
<ul>
<li>add：加</li>
<li>subtract：减</li>
<li>multiple：乘</li>
<li>divide：除<ul>
<li>除的时候尽量使用三个参数的版本：指定保留规则RoundingMode</li>
</ul>
</li>
<li>compareTo：<code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1 表示 <code>a</code> 大于 <code>b</code>。<ul>
<li>比较不能使用equals，因为equals比较会同时比较精度，1.0和1.00不相同</li>
</ul>
</li>
<li>setScale：保留小数</li>
</ul>
<p>工具类：</p>
<pre><code class="java">
import java.math.BigDecimal;
import java.math.RoundingMode;
/**
 * 简化BigDecimal计算的小工具类
 */
public class BigDecimalUtil &#123;
    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;
    private BigDecimalUtil() &#123;
    &#125;
    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) &#123;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.add(b2).doubleValue();
    &#125;
    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double subtract(double v1, double v2) &#123;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.subtract(b2).doubleValue();
    &#125;
    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double multiply(double v1, double v2) &#123;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.multiply(b2).doubleValue();
    &#125;
    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2) &#123;
        return divide(v1, v2, DEF_DIV_SCALE);
    &#125;
    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2, int scale) &#123;
        if (scale &lt; 0) &#123;
            throw new IllegalArgumentException(
                    &quot;The scale must be a positive integer or zero&quot;);
        &#125;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();
    &#125;
    /**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v, int scale) &#123;
        if (scale &lt; 0) &#123;
            throw new IllegalArgumentException(
                    &quot;The scale must be a positive integer or zero&quot;);
        &#125;
        BigDecimal b = BigDecimal.valueOf(v);
        BigDecimal one = new BigDecimal(&quot;1&quot;);
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    &#125;
    /**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static float convertToFloat(double v) &#123;
        BigDecimal b = new BigDecimal(v);
        return b.floatValue();
    &#125;
    /**
     * 提供精确的类型转换(Int)不进行四舍五入
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static int convertsToInt(double v) &#123;
        BigDecimal b = new BigDecimal(v);
        return b.intValue();
    &#125;
    /**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static long convertsToLong(double v) &#123;
        BigDecimal b = new BigDecimal(v);
        return b.longValue();
    &#125;
    /**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */
    public static double returnMax(double v1, double v2) &#123;
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.max(b2).doubleValue();
    &#125;
    /**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */
    public static double returnMin(double v1, double v2) &#123;
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.min(b2).doubleValue();
    &#125;
    /**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */
    public static int compareTo(double v1, double v2) &#123;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.compareTo(b2);
    &#125;
&#125;
</code></pre>
<h3 id="15-7-Unsafe类"><a href="#15-7-Unsafe类" class="headerlink" title="15.7. Unsafe类"></a>15.7. <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/unsafe.html">Unsafe类</a></h3><p>在JUC高并发编程中主要使用，用来执行本地方法（native方法）。</p>
<p>native方法的执行绕过了Java本身的界限。能直接接触到操作系统底层的某些功能，因此并不安全。</p>
<p>可以实现的功能：</p>
<ol>
<li>内存操作</li>
<li>内存屏障</li>
<li>对象操作</li>
<li>数据操作</li>
<li>CAS 操作</li>
<li>线程调度</li>
<li>Class 操作</li>
<li>系统信息</li>
</ol>
<p>因为其不安全性，并不推荐使用。</p>
<h2 id="16-算法"><a href="#16-算法" class="headerlink" title="16. 算法"></a>16. 算法</h2><h3 id="16-1-字符串算法"><a href="#16-1-字符串算法" class="headerlink" title="16.1. 字符串算法"></a>16.1. 字符串算法</h3><h4 id="16-1-1-字符串最长匹配串（KMP）"><a href="#16-1-1-字符串最长匹配串（KMP）" class="headerlink" title="16.1.1. 字符串最长匹配串（KMP）"></a>16.1.1. 字符串最长匹配串（KMP）</h4><p>核心：对于匹配串生成一个失配表，根据失配表进行匹配</p>
<p>失配表：匹配串的第几位没有匹配成功，再从匹配串的某一位重新匹配</p>
<h4 id="16-1-2-替换字符"><a href="#16-1-2-替换字符" class="headerlink" title="16.1.2. 替换字符"></a>16.1.2. 替换字符</h4><p>调用replace方法即可</p>
<h4 id="16-1-3-最长前缀匹配"><a href="#16-1-3-最长前缀匹配" class="headerlink" title="16.1.3. 最长前缀匹配"></a>16.1.3. 最长前缀匹配</h4><p>先利用 Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可（sort的时候数字排在最前面）</p>
<h4 id="16-1-4-构建回文串"><a href="#16-1-4-构建回文串" class="headerlink" title="16.1.4. 构建回文串"></a>16.1.4. 构建回文串</h4><ul>
<li>出现的字符次数是偶数的情况</li>
<li>出现的字符次数是偶数的组合+最长的奇数组合</li>
</ul>
<h4 id="16-1-5-验证回文串"><a href="#16-1-5-验证回文串" class="headerlink" title="16.1.5. 验证回文串"></a>16.1.5. 验证回文串</h4><p>从两边向中间遍历</p>
<h4 id="16-1-6-最长回文子序列"><a href="#16-1-6-最长回文子序列" class="headerlink" title="16.1.6. 最长回文子序列"></a>16.1.6. 最长回文子序列</h4><p>**动态规划： **TOREAD</p>
<pre><code> dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])
</code></pre>
<h4 id="16-1-7-括号的匹配深度"><a href="#16-1-7-括号的匹配深度" class="headerlink" title="16.1.7. 括号的匹配深度"></a>16.1.7. 括号的匹配深度</h4><p>while(replace(“()”,””) !&#x3D; -1)</p>
<h4 id="16-1-8-字符串转换为整数"><a href="#16-1-8-字符串转换为整数" class="headerlink" title="16.1.8. 字符串转换为整数"></a>16.1.8. 字符串转换为整数</h4><p>实现 Integer.valueOf(string)的功能，但是 string 不符合数字要求时返回 0</p>
<pre><code class="java">//https://www.weiweiblog.cn/strtoint/
public class Main &#123;

  public static int StrToInt(String str) &#123;
    if (str.length() == 0)
      return 0;
    char[] chars = str.toCharArray();
    // 判断是否存在符号位
    int flag = 0;
    if (chars[0] == &#39;+&#39;)
      flag = 1;
    else if (chars[0] == &#39;-&#39;)
      flag = 2;
    int start = flag &gt; 0 ? 1 : 0;
    int res = 0;// 保存结果
    for (int i = start; i &lt; chars.length; i++) &#123;
      if (Character.isDigit(chars[i])) &#123;// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False
        int temp = chars[i] - &#39;0&#39;;
        res = res * 10 + temp;
      &#125; else &#123;
        return 0;
      &#125;
    &#125;
   return flag != 2 ? res : -res;

  &#125;

  public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    String s = &quot;-12312312&quot;;
    System.out.println(&quot;使用库函数转换：&quot; + Integer.valueOf(s));
    int res = Main.StrToInt(s);
    System.out.println(&quot;使用自己写的方法转换：&quot; + res);

  &#125;

&#125;
</code></pre>
<h3 id="16-2-链表算法"><a href="#16-2-链表算法" class="headerlink" title="16.2. 链表算法"></a>16.2. 链表算法</h3><h4 id="16-2-1-两数相加"><a href="#16-2-1-两数相加" class="headerlink" title="16.2.1. 两数相加"></a>16.2.1. 两数相加</h4><h4 id="16-2-2-反转链表"><a href="#16-2-2-反转链表" class="headerlink" title="16.2.2. 反转链表"></a>16.2.2. 反转链表</h4><h4 id="16-2-3-链表中倒数第K个数"><a href="#16-2-3-链表中倒数第K个数" class="headerlink" title="16.2.3. 链表中倒数第K个数"></a>16.2.3. 链表中倒数第K个数</h4><p>两个节点同时向后，第一个节点走到第k个，第二个再开始走。</p>
<p>第一个节点到末尾，第二个节点就到倒数第k个</p>
<h4 id="16-2-4-合并两个排序的链表"><a href="#16-2-4-合并两个排序的链表" class="headerlink" title="16.2.4. 合并两个排序的链表"></a>16.2.4. 合并两个排序的链表</h4><h3 id="16-3-部分常见题目"><a href="#16-3-部分常见题目" class="headerlink" title="16.3. 部分常见题目"></a>16.3. 部分常见题目</h3><h4 id="16-3-1-斐波那契数列"><a href="#16-3-1-斐波那契数列" class="headerlink" title="16.3.1. 斐波那契数列"></a>16.3.1. 斐波那契数列</h4><p>递归法：容易因为重复计算超时</p>
<p>迭代法：</p>
<pre><code class="java">int Fibonacci(int number) &#123;
    if (number &lt;= 0) &#123;
        return 0;
    &#125;
    if (number == 1 || number == 2) &#123;
        return 1;
    &#125;
    int first = 1, second = 1, third = 0;
    for (int i = 3; i &lt;= number; i++) &#123;
        third = first + second;
        first = second;
        second = third;
    &#125;
    return third;
&#125;
</code></pre>
<h4 id="16-3-2-跳台阶：也是斐波那契数列"><a href="#16-3-2-跳台阶：也是斐波那契数列" class="headerlink" title="16.3.2. 跳台阶：也是斐波那契数列"></a>16.3.2. 跳台阶：也是斐波那契数列</h4><h4 id="16-3-3-变态跳台阶：一个可以跳n个"><a href="#16-3-3-变态跳台阶：一个可以跳n个" class="headerlink" title="16.3.3. 变态跳台阶：一个可以跳n个"></a>16.3.3. 变态跳台阶：一个可以跳n个</h4><p>假设 n&gt;&#x3D;2，第一步有 n 种跳法：跳 1 级、跳 2 级、到跳 n 级 跳 1 级，剩下 n-1 级，则剩下跳法是 f(n-1) 跳 2 级，剩下 n-2 级，则剩下跳法是 f(n-2) …… 跳 n-1 级，剩下 1 级，则剩下跳法是 f(1) 跳 n 级，剩下 0 级，则剩下跳法是 f(0) 所以在 n&gt;&#x3D;2 的情况下： f(n)&#x3D;f(n-1)+f(n-2)+…+f(1) 因为 f(n-1)&#x3D;f(n-2)+f(n-3)+…+f(1) 所以 f(n)&#x3D;2<em>f(n-1) 又 f(1)&#x3D;1,所以可得*<em>f(n)&#x3D;2^(number-1)</em></em></p>
<p>java 中有三种移位运算符：</p>
<ol>
<li>“&lt;&lt;” : <strong>左移运算符</strong>，等同于乘 2 的 n 次方</li>
<li>“&gt;&gt;”: <strong>右移运算符</strong>，等同于除 2 的 n 次方</li>
<li>“&gt;&gt;&gt;” : <strong>无符号右移运算符</strong>，不管移动前最高位是 0 还是 1，右移后左侧产生的空位部分都以 0 来填充。与&gt;&gt;类似。</li>
</ol>
<h4 id="16-3-4-二维数组查找"><a href="#16-3-4-二维数组查找" class="headerlink" title="16.3.4. 二维数组查找"></a>16.3.4. 二维数组查找</h4><h4 id="16-3-5-调整数组顺序使奇数位于偶数前面"><a href="#16-3-5-调整数组顺序使奇数位于偶数前面" class="headerlink" title="16.3.5. 调整数组顺序使奇数位于偶数前面"></a>16.3.5. 调整数组顺序使奇数位于偶数前面</h4><p>思路：统计奇数个数，假设为n</p>
<p>遍历数组，奇数从0存，偶数从n存</p>
<h4 id="16-3-6-两个栈实现队列"><a href="#16-3-6-两个栈实现队列" class="headerlink" title="16.3.6. 两个栈实现队列"></a>16.3.6. 两个栈实现队列</h4><h4 id="16-3-7-栈的压入弹出序列"><a href="#16-3-7-栈的压入弹出序列" class="headerlink" title="16.3.7. 栈的压入弹出序列"></a>16.3.7. 栈的压入弹出序列</h4><p>判断弹出序列是否合法。使用两个栈，第一个栈出的元素不是序列要的，就压入弹出序列，如果原栈为空，弹出栈的栈首不是要求序列则不对。</p>
<h3 id="16-4-排序算法"><a href="#16-4-排序算法" class="headerlink" title="16.4. 排序算法"></a>16.4. 排序算法</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/algorithms/10-classical-sorting-algorithms.html">十大排序算法图解-JavaGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/data-structures/">菜鸟教程数据结构</a></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 2738430398@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2023- Gohoy
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/blog/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/blog/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







<div id="musicMouseDrag" style="position:fixed; z-index: 9999; bottom: 0; right: 0;">
<div id="musicDragArea" style="position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;"></div>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=8700654240&auto=1&height=430"></iframe>
</div>
<!--以下代码是为了支持随时拖动音乐控件的位置，如没有需求，可去掉下面代码-->
<script>
var $DOC = $(document)
$('#musicMouseDrag').on('mousedown', function (e) {
// 阻止文本选中
$DOC.bind("selectstart", function () {
return false;
});
$('#musicDragArea').css('height', '100%');
var $moveTarget = $('#musicMouseDrag');
$moveTarget.css('border', '1px dashed grey')
var div_x = e.pageX - $moveTarget.offset().left;
var div_y = e.pageY - $moveTarget.offset().top;
$DOC.on('mousemove', function (e) {
var targetX = e.pageX - div_x;
var targetY = e.pageY - div_y;
targetX = targetX < 0 ? 0 : (targetX + $moveTarget.outerWidth() >= window.innerWidth) ? window.innerWidth - $moveTarget.outerWidth() : targetX;
targetY = targetY < 0 ? 0 : (targetY + $moveTarget.outerHeight() >= window.innerHeight) ? window.innerHeight - $moveTarget.outerHeight() : targetY;
$moveTarget.css({'left': targetX + 'px', 'top': targetY + 'px', 'bottom': 'inherit', 'right': 'inherit'})
}).on('mouseup', function () {
$DOC.unbind("selectstart");
$DOC.off('mousemove')
$DOC.off('mouseup')
$moveTarget.css('border', 'none')
$('#musicDragArea').css('height', '10px');
})
})
</script>
</html>
