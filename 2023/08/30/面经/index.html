<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java面经记录 | Hexo</title>
  <meta name="keywords" content=" Java , 面经 , 八股文 ">
  <meta name="description" content="Java面经记录 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="springboot查询数据库字段实践任务描述：在订单管理中增加购票信息界面、 查询条件：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、票类型 显示字段：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、二维码（限制显示长度20字符）、购票时间、票类型 可效仿订单管理页。 后端实现步骤：查看需要查询的表的字段 表名为t_business_member_ticket  字">
<meta property="og:type" content="article">
<meta property="og:title" content="springboot查询数据库字段实践">
<meta property="og:url" content="https://gohoy.github.io/blog/2023/09/05/springboot%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="springboot查询数据库字段实践任务描述：在订单管理中增加购票信息界面、 查询条件：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、票类型 显示字段：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、二维码（限制显示长度20字符）、购票时间、票类型 可效仿订单管理页。 后端实现步骤：查看需要查询的表的字段 表名为t_business_member_ticket  字">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-09-05T11:23:59.427Z">
<meta property="article:modified_time" content="2023-09-11T13:29:38.328Z">
<meta property="article:author" content="Gohoy">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="springboot">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/blog/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/blog/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/blog/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="/blog">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/"
   class="avatar_target">
    <img class="avatar"
         src="/blog/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Gohoy</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/gohoy"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:2738430398@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2738430398&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(19)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="吉他谱">
            
            吉他谱
            <small>(8)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="教程">
            
            教程
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="理论">
            
            理论
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="设计文档">
            
            设计文档
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="docker">
            
            docker
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Java">
            
            Java
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="K8S">
            
            K8S
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="19">
<input type="hidden" id="yelog_site_word_count" value="31.2k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>八股文</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>负载均衡</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>概率论</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>吉他谱</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>教程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面经</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计文档</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>四子ding</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>掷筛</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>arm64</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Centos</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>contianer</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>https</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>K8S</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mydisk</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NdS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>openEuler</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springboot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ssl</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All Java "
           href="/blog/2023/09/05/springboot%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E5%AE%9E%E8%B7%B5/"
           data-tag="Java,springboot"
           data-author="" >
            <span class="post-title" title="springboot查询数据库字段实践">springboot查询数据库字段实践</span>
            <span class="post-date" title="2023-09-05 19:23:59">2023/09/05</span>
        </a>
        
        
        <a  class="All 教程 "
           href="/blog/2023/09/04/%E4%BD%BF%E7%94%A8Let's%20Encrypt%E7%BB%99%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0SSL/"
           data-tag="教程,ssl,https"
           data-author="" >
            <span class="post-title" title="使用Let&#39;s Encrypt给网站添加SSL">使用Let&#39;s Encrypt给网站添加SSL</span>
            <span class="post-date" title="2023-09-04 18:49:32">2023/09/04</span>
        </a>
        
        
        <a  class="All Java "
           href="/blog/2023/08/30/%E9%9D%A2%E7%BB%8F/"
           data-tag="Java,面经,八股文"
           data-author="" >
            <span class="post-title" title="Java面经记录">Java面经记录</span>
            <span class="post-date" title="2023-08-30 14:50:59">2023/08/30</span>
        </a>
        
        
        <a  class="All K8S "
           href="/blog/2023/08/30/k8s-web%E6%9C%80%E7%BB%88%E6%96%87%E6%A1%A3/"
           data-tag="K8S"
           data-author="" >
            <span class="post-title" title="K8S-WEB最终文档">K8S-WEB最终文档</span>
            <span class="post-date" title="2023-08-30 14:45:47">2023/08/30</span>
        </a>
        
        
        <a  class="All K8S "
           href="/blog/2023/08/30/%E9%87%8D%E8%A3%85k8s%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E6%A1%A3/"
           data-tag="K8S,教程,openEuler,arm64"
           data-author="" >
            <span class="post-title" title="openEuler安装K8S文档">openEuler安装K8S文档</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 理论 "
           href="/blog/2023/08/30/%E6%B8%B8%E6%88%8F%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E6%A6%82%E7%8E%87%E8%AE%BA/"
           data-tag="概率论,掷筛,NdS"
           data-author="" >
            <span class="post-title" title="游戏掷筛">游戏掷筛</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E5%B0%8F%E5%B9%B8%E8%BF%90%E5%90%89%E4%BB%96/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="小幸运吉他谱">小幸运吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E6%9C%AA%E9%97%BB%E8%8A%B1%E5%90%8D/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="未闻花名吉他谱">未闻花名吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 设计文档 "
           href="/blog/2023/08/30/%E5%9B%9B%E5%AD%90ding%20%E8%AE%BE%E8%AE%A1/"
           data-tag="设计文档,四子ding"
           data-author="" >
            <span class="post-title" title="四子ding设计">四子ding设计</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E8%AF%B4%E5%A5%BD%E7%9A%84%E5%B9%B8%E7%A6%8F%E5%91%A2/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="说好的幸福呢吉他谱">说好的幸福呢吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E6%99%B4%E5%A4%A9/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="晴天吉他谱">晴天吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E5%85%B0%E4%BA%AD%E5%BA%8F%E5%90%89%E4%BB%96%E8%B0%B1/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="兰亭序吉他谱">兰亭序吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E8%8A%B1%E6%B5%B7%E5%90%89%E4%BB%96%E8%B0%B1/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="花海吉他谱">花海吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All docker "
           href="/blog/2023/08/30/%E6%9E%84%E5%BB%BAopenEuler%E7%9A%84docker%E5%AE%B9%E5%99%A8/"
           data-tag="教程,docker,contianer,openEuler"
           data-author="" >
            <span class="post-title" title="openEuler docker container构建">openEuler docker container构建</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="爱在西元前吉他谱">爱在西元前吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 设计文档 "
           href="/blog/2023/08/30/Mydisk%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"
           data-tag="设计文档,Mydisk"
           data-author="" >
            <span class="post-title" title="Mydisk项目说明">Mydisk项目说明</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All 吉他谱 "
           href="/blog/2023/08/30/Lemon%E5%90%89%E4%BB%96%E8%B0%B1/"
           data-tag="吉他谱"
           data-author="" >
            <span class="post-title" title="Lemon吉他谱">Lemon吉他谱</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All K8S "
           href="/blog/2023/08/30/k8s%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/"
           data-tag="K8S,负载均衡"
           data-author="" >
            <span class="post-title" title="K8S负载均衡方案">K8S负载均衡方案</span>
            <span class="post-date" title="2023-08-30 14:28:51">2023/08/30</span>
        </a>
        
        
        <a  class="All K8S "
           href="/blog/2023/08/30/CentOS%E5%AE%89%E8%A3%85K8S%E6%96%87%E6%A1%A3/"
           data-tag="Centos,K8S,教程"
           data-author="" >
            <span class="post-title" title="Centos7 安装 k8s">Centos7 安装 k8s</span>
            <span class="post-date" title="2023-08-30 14:25:32">2023/08/30</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-面经" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java面经记录</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java">Java</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">Java</a>
            
            <a class="color3">面经</a>
            
            <a class="color4">八股文</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2023-09-19 10:57:26'>2023-08-30 14:50</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:15.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">Java基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E6%98%AF%E7%BC%96%E8%AF%91%E5%92%8C%E8%A7%A3%E9%87%8A%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">为什么说Java是编译和解释的语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法中为什么不能调用非静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="toc-text">重载和重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0public-void-test-String-%E2%80%A6args"><span class="toc-text">可变长参数public void test(String …args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-text">对象实体和对象引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%BB%98%E8%AE%A4%E6%9C%89%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%EF%BC%8C%E4%BD%86%E5%88%9B%E5%BB%BA%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%90%8E%E8%A6%81%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E3%80%82"><span class="toc-text">对象默认有无参构造，但创建有参构造后要手动创建无参构造。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">接口和抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Object 的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-StringBuffer-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">String StringBuffer StringBuilder 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E6%8B%BC%E6%8E%A5%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8Cintern%E6%96%B9%E6%B3%95"><span class="toc-text">String拼接、赋值和intern方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%88%AB%EF%BC%9A"><span class="toc-text">类别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E6%8E%92%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">Set排序接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7"><span class="toc-text">无序性和不可重复性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue%E5%92%8CDeque%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Queue和Deque的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayDeque%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">ArrayDeque和LinkedList的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityQueue"><span class="toc-text">PriorityQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockingQueue%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">BlockingQueue（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%88%AB"><span class="toc-text">类别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%EF%BC%9A"><span class="toc-text">HashMap：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable%EF%BC%88%E6%8E%A5%E8%BF%91%E6%B7%98%E6%B1%B0%EF%BC%89%EF%BC%9A"><span class="toc-text">HashTable（接近淘汰）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">HashMap和HashSet的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">Collections工具类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-text">集合的建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">常用数据结构源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81"><span class="toc-text">HashMap源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">实现线程安全的方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E5%AD%98%E6%94%BEnull%E5%92%8Cnullkey"><span class="toc-text">不允许存放null和nullkey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">不能保证复合操作的原子性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">synchronized关键字的底层原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">CAS的理解和底层实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9CAtomicInterger%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">线程操作AtomicInterger基本流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E4%B8%AD%E7%9A%84AQS%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">JDK中的AQS的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">线程池的底层工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A"><span class="toc-text">线程池：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">线程池的核心配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">如果在线程池中使用无界阻塞队列会发生什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">线程池队列满了之后，会发生什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%BA%E5%99%A8%E7%AA%81%E7%84%B6%E5%AE%95%E6%9C%BA%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">如果机器突然宕机，线程池的阻塞队列的任务怎么办</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-text">内存泄漏问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future%E7%B1%BB"><span class="toc-text">Future类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream"><span class="toc-text">InputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream"><span class="toc-text">FileInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataInputStream"><span class="toc-text">DataInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectInputStream"><span class="toc-text">ObjectInputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutPutStream"><span class="toc-text">OutPutStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileOutputStream"><span class="toc-text">FileOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DataOutputStream"><span class="toc-text">DataOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectInputStream-1"><span class="toc-text">ObjectInputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader"><span class="toc-text">Reader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStreamReader-FileReader"><span class="toc-text">InputStreamReader FileReader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Writer"><span class="toc-text">Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputStreamWriter-FileWriter"><span class="toc-text">OutputStreamWriter FileWriter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81BufferedInputStream-BufferedOutputStream"><span class="toc-text">字符缓冲流BufferedInputStream BufferedOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81-PrintStream"><span class="toc-text">打印流 PrintStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81-RandomAccessFile"><span class="toc-text">随机访问流 RandomAccessFile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">谈谈对Java内存模型的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">可见性、原子性、有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%BA%95%E5%B1%82%E8%A7%92%E5%BA%A6%E8%81%8Avolatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86"><span class="toc-text">从底层角度聊volatile关键字原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%92%8Chappens-before%E5%8E%9F%E5%88%99"><span class="toc-text">指令重排和happens-before原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">volatile底层如何基于内存屏障保证可见性和有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E7%9A%84IOC"><span class="toc-text">Spring的IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E7%9A%84AOP"><span class="toc-text">Spring的AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E8%BF%87cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%90%97%EF%BC%8C%E4%BB%96%E5%92%8Cjdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">了解过cglib动态代理吗，他和jdk动态代理的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">spring事务的实现原理是什么，事务传播机制是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Springboot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="toc-text">Springboot 的核心架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81"><span class="toc-text">Spring 核心源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">Spring中的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E6%9E%B6%E6%9E%84"><span class="toc-text">SpringMVC架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringCloud%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="toc-text">SpringCloud核心架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E5%9D%97%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%8CJava8%E4%B9%8B%E5%90%8E%E5%AF%B9%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E6%94%B9%E8%BF%9B"><span class="toc-text">JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%90%84%E7%A7%8D%E5%AF%B9%E8%B1%A1"><span class="toc-text">JVM如何运行起来的，如何创建各种对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">JVM什么时候会触发垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AF%B9%E8%B1%A1%E4%BC%9A%E8%BD%AC%E7%A7%BB%E5%88%B0%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">什么时候对象会转移到老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6"><span class="toc-text">常用的垃圾回收器，老年代如何回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEjvm%E5%8F%82%E6%95%B0%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5jvm%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="toc-text">生产环境如何设置jvm参数的，如何检查jvm的运行情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-GC%E4%BC%98%E5%8C%96"><span class="toc-text">JVM GC优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E7%94%9FOOM%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E5%A4%84%E7%90%86%E7%BA%BF%E4%B8%8A%E7%B3%BB%E7%BB%9F%E7%9A%84OOM%E9%97%AE%E9%A2%98"><span class="toc-text">发生OOM之后，应该如何排查和处理线上系统的OOM问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E7%9A%84%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">TCP&#x2F;IP的四层模型和七层网络模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEbaidu-com%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">浏览器访问baidu.com会发生什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%BA%94%E6%AC%A1%E6%88%96%E8%80%85%E4%B8%A4%E6%AC%A1%EF%BC%9F"><span class="toc-text">TCP三次握手和四次挥手的流程，为什么不是五次或者两次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bhttp%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">说一下http长连接的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https-http-ssl-tsl"><span class="toc-text">https http+ssl&#x2F;tsl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%EF%BC%9Amysiam-innodb"><span class="toc-text">引擎：mysiam innodb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%82"><span class="toc-text">Mysql索引原理和数据结构。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">索引的使用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%89%B9%E7%82%B9"><span class="toc-text">事务的几个特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81"><span class="toc-text">数据库锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%B8%E7%94%A8%E6%89%8B%E6%AE%B5"><span class="toc-text">MySQL调优的常用手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-R%E5%9B%BE"><span class="toc-text">E-R图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket"><span class="toc-text">socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">进程通信和线程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2"><span class="toc-text">线程如何切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nio%EF%BC%8Cbio%EF%BC%8Caio%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82nio%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">nio，bio，aio都是什么，有什么区别。nio的原理是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bio%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">bio通信原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nio%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">nio通信原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aio"><span class="toc-text">aio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">同步阻塞、同步非阻塞、异步非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-NIO-AIO-demo%E4%BB%A3%E7%A0%81"><span class="toc-text">BIO NIO AIO demo代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98"><span class="toc-text">线上服务器问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E4%B8%8ACPU%E5%8D%A0%E7%94%A8100-%EF%BC%8C%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">线上CPU占用100%，排查步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%BA%BF%E4%B8%8A%E8%BF%9B%E7%A8%8Bkill%E4%B8%8D%E6%8E%89%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">如果线上进程kill不掉怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%A9%AC%E4%B8%8A%E5%8D%A0%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">磁盘马上占满了怎么办</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-text">Java语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">泛型和通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">基本操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="toc-text">1.静态代理：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.动态代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">BigDecimal常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe%E7%B1%BB"><span class="toc-text">Unsafe类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95"><span class="toc-text">字符串算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E5%8C%B9%E9%85%8D%E4%B8%B2%EF%BC%88KMP%EF%BC%89"><span class="toc-text">字符串最长匹配串（KMP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6"><span class="toc-text">替换字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D"><span class="toc-text">最长前缀匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">构建回文串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">验证回文串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">最长回文子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%B9%E9%85%8D%E6%B7%B1%E5%BA%A6"><span class="toc-text">括号的匹配深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0"><span class="toc-text">字符串转换为整数</span></a></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-5 i,
    .toc-level-5 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><h3 id="为什么说Java是编译和解释的语言"><a href="#为什么说Java是编译和解释的语言" class="headerlink" title="为什么说Java是编译和解释的语言"></a>为什么说Java是编译和解释的语言</h3><p>Java需要把代码编译成.class的字节码文件，然后再解释成机器码。</p>
<h3 id="静态方法中为什么不能调用非静态方法"><a href="#静态方法中为什么不能调用非静态方法" class="headerlink" title="静态方法中为什么不能调用非静态方法"></a>静态方法中为什么不能调用非静态方法</h3><p>因为静态方法在类创建的时候生成，非静态方法在实例化对象之后才生成。</p>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p>重载：同方法名，不同参数</p>
<p>重写：子类重写父类的方法，方法名参数相同，构造方法无法重写</p>
<h3 id="可变长参数public-void-test-String-…args"><a href="#可变长参数public-void-test-String-…args" class="headerlink" title="可变长参数public void test(String …args)"></a>可变长参数public void test(String …args)</h3><p>可以接收不同长度的参数，重载的时候优先匹配固定长度参数的方法。</p>
<h3 id="对象实体和对象引用"><a href="#对象实体和对象引用" class="headerlink" title="对象实体和对象引用"></a>对象实体和对象引用</h3><p>new 来创建一个对象实体，一个对象实体可以有多个对象引用。一个对象引用可以指向一个对象实体。</p>
<p>对象实体存在堆内存中（类和对象都存放在堆内存中）</p>
<p>对象引用存放在栈内存中</p>
<h3 id="对象默认有无参构造，但创建有参构造后要手动创建无参构造。"><a href="#对象默认有无参构造，但创建有参构造后要手动创建无参构造。" class="headerlink" title="对象默认有无参构造，但创建有参构造后要手动创建无参构造。"></a>对象默认有无参构造，但创建有参构造后要手动创建无参构造。</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>子类在调用父类的方法的时候，只有在运行的时候，才知道调用的是哪个方法（父类的还是子类的），这个方法具有多态性</p>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>相同点：<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法，接口中可以定义default方法来实现</li>
</ul>
</li>
<li>不同点<ul>
<li>接口主要是对对象的约束，约束对象的行为（实现接口的方法）</li>
<li>抽象类主要是代码的复用性的规定</li>
<li>一个类只可以继承一个类，但可以实现多个接口</li>
<li>接口中 的成员变量只能是public static final 类型，有初值，不可变</li>
<li>抽象类中的成员变量默认为default，可在子类中重新定义和赋值</li>
</ul>
</li>
</ul>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：在对上创建一个新对象，如果被拷贝的是引用类型，则会直接复制它引用的地址</p>
<p>深拷贝：复制整个对象，包含内部对象</p>
<h3 id="Object-的常用方法"><a href="#Object-的常用方法" class="headerlink" title="Object 的常用方法"></a>Object 的常用方法</h3><details><summary>点击展开代码</summary><pre><code>/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * native 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable &#123; &#125;</code></pre></details>

<p>hashcode 和 equals 都是判断对象是否相同的方法</p>
<p>hashcode 可能会碰撞，equals 是比较地址但效率较低</p>
<p>重写equals也应当重写hashcode方法。</p>
<h3 id="String-StringBuffer-StringBuilder-的区别"><a href="#String-StringBuffer-StringBuilder-的区别" class="headerlink" title="String StringBuffer StringBuilder 的区别"></a>String StringBuffer StringBuilder 的区别</h3><ul>
<li><p>String 对象不可变，String a &#x3D; “test”;  a &#x3D; “test1” 。更改a的值的时候，是创建了一个新的String对象，将地址赋给a。是线程安全的</p>
</li>
<li><p>StringBuffer 和 StringBuilder 更改值，不用新建对象。</p>
</li>
<li><p>StringBuffer 使用同步锁保证线程安全</p>
</li>
<li><p>StringBuilder 是线程不安全的，效率比StringBUffer快10%-15%</p>
</li>
</ul>
<h3 id="String拼接、赋值和intern方法"><a href="#String拼接、赋值和intern方法" class="headerlink" title="String拼接、赋值和intern方法"></a>String拼接、赋值和intern方法</h3><ul>
<li>在Java9之前，String 用加号连接的方法是使用StringBuilder.append().toString()方法构建的。在之后更新了方法，可以放心使用+连接，性能也不错</li>
<li>String s &#x3D; new String(“abc”); 这段代码可能会创建 1-2 个字符串对象。 先在字符串常量池创建一个字符串对象abc（如果已存在则不需要再创建），然后复制一份到堆内存中。</li>
<li>String intern 方法：将引用保存到字符串常量池中（如果已有则不再保存），并且返回这个对象</li>
</ul>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><ul>
<li>字符串常量池位于<strong>堆内存</strong>中，与堆中的对象实例是分开的。</li>
<li>字符串常量池中的字符串是不可变的，一旦创建就不能修改。</li>
<li>字符串常量池中的字符串可以通过调用 intern() 方法进行显式的添加。该方法将返回常量池中字符串的引用，如果常量池中已存在相同内容的字符串，则返回已存在的引用。</li>
<li>字符串常量池的位置发生了变化，在 Java 7 及之前的版本中，字符串常量池位于永久代（PermGen），而在 Java 8 及以后的版本中，它被转移到了堆内存中。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>顺序存储</p>
<ul>
<li><p>ArrayList</p>
<ul>
<li><p>ArrayList和Array的区别</p>
</li>
<li><table>
<thead>
<tr>
<th></th>
<th>ArrayList</th>
<th>Array</th>
</tr>
</thead>
<tbody><tr>
<td>长度</td>
<td>可变</td>
<td>固定</td>
</tr>
<tr>
<td>用泛型</td>
<td>可</td>
<td>不可</td>
</tr>
<tr>
<td>存放类型</td>
<td>仅对象</td>
<td>对象和基本类型</td>
</tr>
<tr>
<td>内置方法</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>创建指定大小</td>
<td>无需</td>
<td>必须</td>
</tr>
<tr>
<td>存放null</td>
<td>可</td>
<td>不可</td>
</tr>
</tbody></table>
<p>ArrayList和LinkedList操作的时间复杂度。</p>
</li>
<li><table>
<thead>
<tr>
<th></th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>头插</td>
<td>O（n）</td>
<td>O（1）</td>
</tr>
<tr>
<td>尾插</td>
<td>O（1）或O（n） （扩容）</td>
<td>O（1）</td>
</tr>
<tr>
<td>中间插入</td>
<td>O（n）后面的要向后移动</td>
<td>O（n）找到插入的位置</td>
</tr>
<tr>
<td>头删</td>
<td>O（n）</td>
<td>O（1）</td>
</tr>
<tr>
<td>尾删</td>
<td>O（1）</td>
<td>O（1）</td>
</tr>
<tr>
<td>中间删除</td>
<td>O（n）</td>
<td>O（n）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Vector: <code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</p>
</li>
<li><p>LinkedList</p>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="类别："><a href="#类别：" class="headerlink" title="类别："></a>类别：</h4><ul>
<li>HashSet：无序，唯一，使用HashMap实现</li>
<li>LinkedHashSet：使用LinkedHashMap实现</li>
<li>TreeSet：有序，唯一  也叫：红黑树 （自平衡的排序二叉树）</li>
</ul>
<h4 id="Set排序接口"><a href="#Set排序接口" class="headerlink" title="Set排序接口"></a>Set排序接口</h4><ul>
<li>Comparable：实现方法obj.compareTo(obj1);</li>
<li>Comparator：实现方法compare(obj1,obj2);</li>
</ul>
<h4 id="无序性和不可重复性"><a href="#无序性和不可重复性" class="headerlink" title="无序性和不可重复性"></a>无序性和不可重复性</h4><p>无序性：存储元素的顺序是按照key散列之后存储在对应位置，不是按顺序一个一个存储</p>
<p>不可重复性：equals不能相同，同时需要重写hashcode和equals方法</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul>
<li>PriorityQueue：数组实现的二叉堆</li>
<li>ArrayQueue：数组和双指针实现</li>
</ul>
<h4 id="Queue和Deque的区别"><a href="#Queue和Deque的区别" class="headerlink" title="Queue和Deque的区别"></a>Queue和Deque的区别</h4><p>Queue是单端队列，Deque是双端队列</p>
<p>Queue实现了Collection接口</p>
<p>Deque扩展了Queue接口，增加了队首删除和加入的方法，根据错误处理方式有两种不同操作方法</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法来模拟栈</p>
<h4 id="ArrayDeque和LinkedList的区别"><a href="#ArrayDeque和LinkedList的区别" class="headerlink" title="ArrayDeque和LinkedList的区别"></a>ArrayDeque和LinkedList的区别</h4><table>
<thead>
<tr>
<th></th>
<th>ArrayQueue</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>底层</td>
<td>数组+双指针</td>
<td>链表</td>
</tr>
<tr>
<td>可存储null</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>需要扩容</td>
<td>可能需要，但插入均摊性能高</td>
<td>否，但插入元素需要申请内存，均摊性能稍低</td>
</tr>
</tbody></table>
<p>ArrayQueue的性能比LinkedList好，并且可以实现栈。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>PriorityQueue和Queue的区别是：PriorityQueue是根据优先级出队的</p>
<p>细节TODO</p>
<h4 id="BlockingQueue（了解）"><a href="#BlockingQueue（了解）" class="headerlink" title="BlockingQueue（了解）"></a>BlockingQueue（了解）</h4><p>没有元素会阻塞，直到有元素。如果队列已满，会阻塞插入操作。</p>
<p>用来实现生产者消费者等部分。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><ul>
<li>HashMap：不保证FIFO，不是先来先存储，通过散列，选择一个位置存放</li>
<li>LinkedHashMap：保证FIFO</li>
<li>HashTable：</li>
<li>TreeMap：</li>
</ul>
<h4 id="HashMap："><a href="#HashMap：" class="headerlink" title="HashMap："></a>HashMap：</h4><p>[hashMap](# HashMap源码)</p>
<h4 id="HashTable（接近淘汰）："><a href="#HashTable（接近淘汰）：" class="headerlink" title="HashTable（接近淘汰）："></a>HashTable（接近淘汰）：</h4><p>线程安全，效率稍低，不支持存储null或nullkey，容量默认为11，之后扩容为2n+1</p>
<h4 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h4><p>HashSet是HashMap实现的</p>
<p><code>HashSet</code> 的源码非常非常少，除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<ul>
<li>HashSet的去重：调用HashMap的add方法，根据返回值判断是否重复</li>
<li>HashMap的判断重复：计算hash值-&gt;相同equals-&gt;再相同则重复</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序</p>
<p>想要重写排序</p>
<pre><code class="java">TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person person1, Person person2) &#123;
                int num = person1.getAge() - person2.getAge();
                return Integer.compare(num, 0);
            &#125;
&#125;);
</code></pre>
<p>比HashMap多了元素根据键排序和对集合内元素的搜索能力</p>
<h3 id="Collections工具类方法"><a href="#Collections工具类方法" class="headerlink" title="Collections工具类方法"></a>Collections工具类方法</h3><pre><code class="java">//排序
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面

//查找 替换
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
</code></pre>
<p>同步操作（不推荐，建议使用JUC）</p>
<h3 id="集合的建议"><a href="#集合的建议" class="headerlink" title="集合的建议"></a>集合的建议</h3><ul>
<li><p>判空使用<code>isEmpty()</code>方法</p>
</li>
<li><p>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p>
</li>
<li><p>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。<code>Collection#removeIf()</code>方法删除满足特定条件的元素</p>
</li>
<li><p>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</p>
</li>
<li><p>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</p>
</li>
<li><p>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</p>
<ul>
<li><p>推荐解决方法</p>
<pre><code class="java">Integer [] myArray = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
</code></pre>
</li>
<li><p>最简单的解决办法</p>
<pre><code class="java">Integer [] myArray = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = &#123; 1, 2, 3 &#125;;
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="常用数据结构源码解析"><a href="#常用数据结构源码解析" class="headerlink" title="常用数据结构源码解析"></a>常用数据结构源码解析</h2><h3 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h3><ul>
<li><p>底层是数组+链表+红黑树，非线程安全</p>
<ul>
<li>为什么非线程安全<ul>
<li><p>线程一进行完hash碰撞判断之后，时间片用尽，线程二完成了hash计算和插入操作，此时线程一直接插入，会覆盖线程二插入的值</p>
</li>
<li><p>同时put导致size值不对</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可存储null的key和value</p>
</li>
<li><p>初始大小16，扩容到当前的二倍（一定是2的幂次方，便于取余计算）</p>
</li>
<li><p>获取Key的方法：</p>
<ul>
<li><pre><code class="java">static final int hash(Object key) &#123;
  int h;
  // key.hashCode()：返回散列值也就是hashcode
  // ^：按位异或
  // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐
  return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>元素添加：</p>
<ul>
<li>获取数组的index：key对hashmap的length取模（将key和length-1与，比%取模的性能好）</li>
<li>如果这个index没有元素，直接添加</li>
<li>如果有元素则比较key，如果key相同则覆盖。</li>
<li>如果是hash碰撞，则判断是否是树节点，是就调用putTreeVal加入树节点，否则加入链表尾部</li>
</ul>
</li>
<li><p>hash碰撞使用拉链法</p>
<ul>
<li>在hash碰撞的节点创建一个链表，把碰撞的值都放在链表中</li>
<li>链表元素超过8个，将链表切换成红黑树</li>
</ul>
</li>
<li><p>扩容条件是存放的元素数量超过<code>容量*负载因子</code></p>
<ul>
<li>负载因子<strong>loadFactor</strong> 是控制数组存放数据的疏密程度<ul>
<li>loadFactor越趋近1，数组中存储的元素就越多，碰撞的元素在链表的长度就越多，查询性能下降</li>
<li>loadFactor越趋近0，hashMap扩容次数增加，rehash消耗性能</li>
<li>官方给出的默认为0.75</li>
</ul>
</li>
<li>resize就是扩容之后重新计算index和hash<ul>
<li>底层就是新开一个数组，将元素重新放入新数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。线程不安全。</p>
<ul>
<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>RandomAccess</code> ：表明它可以快速进行随机访问，get(index)</li>
<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>
<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>
</ul>
</li>
<li><p>可以添加null值。</p>
</li>
<li><p>底层是Object数组。</p>
</li>
<li><p>时间复杂度：add() O(1) ;   add(index,val) O(n) ;</p>
</li>
<li><p>空间占用主要是末尾预留的空间。</p>
</li>
<li><p>在添加大量元素的时候，可以提前使用ensureCapacity(N)方法预留空间，减少空间分配次数，节约性能。</p>
</li>
<li><p>当添加元素大于容量的时候，触发扩容</p>
<ul>
<li>扩容：每次newSize&#x3D; oldSize+oldSize&#x2F;2 相当于1.5倍</li>
</ul>
</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul>
<li><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</li>
<li><code>LinkedList</code> 实现了<code>List</code>,<code>Deque</code>,<code>Cloneable</code>,<code>Seralizable</code><ul>
<li><code>Deque</code>：表明它具有双端队列特性，便于两端插入和删除</li>
</ul>
</li>
<li>底层是双向链表</li>
<li>时间复杂度：add() O(1); add(index,val) O(n) </li>
<li>空间占用主要是除了data之外的索引等数据</li>
<li>遍历常用for-each</li>
<li>基本上不用LinkedList，都用ArrayList，性能一般更好一些</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="实现线程安全的方法："><a href="#实现线程安全的方法：" class="headerlink" title="实现线程安全的方法："></a>实现线程安全的方法：</h4><ul>
<li>JDK1.7的时候：使用Segment数组（锁的个数，默认16，不可扩容）+HashEntry数组+链表实现。使用分段锁，将数据分段保护。最多支持16个线程并发（默认）</li>
<li>JDK1.8的时候：使用（node数组+链表）&#x2F;（红黑树）实现。主要使用CAS和synchronized操作，保留一些分段锁用来兼容旧版本。synchronized锁定链表节点或者红黑树首节点。因此只要hash不碰撞都可以进行并发操作。</li>
</ul>
<h4 id="不允许存放null和nullkey"><a href="#不允许存放null和nullkey" class="headerlink" title="不允许存放null和nullkey"></a>不允许存放null和nullkey</h4><p>避免二义性，不同线程使用containsKey来判断是否存在元素，如果存储null就不知道到底是有还是没有值。</p>
<h4 id="不能保证复合操作的原子性"><a href="#不能保证复合操作的原子性" class="headerlink" title="不能保证复合操作的原子性"></a>不能保证复合操作的原子性</h4><pre><code class="java">// 线程 A
if (!map.containsKey(key)) &#123;
map.put(key, value);
&#125;
// 线程 B
if (!map.containsKey(key)) &#123;
map.put(key, anotherValue);
&#125;
</code></pre>
<p>不能保证上面的代码正常执行</p>
<p>concurrentHashMap提供了原子性的符合操作方法：<code>putIfAbsent()</code>或<code>computeIfAbsent()</code></p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="synchronized关键字的底层原理是什么"><a href="#synchronized关键字的底层原理是什么" class="headerlink" title="synchronized关键字的底层原理是什么"></a>synchronized关键字的底层原理是什么</h3><p>2.1.1synchronized是做什么的</p>
<p><strong>给线程加锁</strong>，加锁目标是一个类或一个对象。</p>
<p>2.1.2实现原理</p>
<p>加锁指令：monitorenter（加锁） monitorexit（释放锁）</p>
<p>一个对象或类关联有一个monitor（计数器：正在使用的线程数，<strong>类似信号量</strong>）</p>
<h3 id="CAS的理解和底层实现原理"><a href="#CAS的理解和底层实现原理" class="headerlink" title="CAS的理解和底层实现原理"></a>CAS的理解和底层实现原理</h3><p>多个线程要访问同一个数据会出现并发安全问题。</p>
<p><code>AtomicInterger</code>并发包的原子类，使用CAS实现。</p>
<h4 id="线程操作AtomicInterger基本流程："><a href="#线程操作AtomicInterger基本流程：" class="headerlink" title="线程操作AtomicInterger基本流程："></a>线程操作AtomicInterger基本流程：</h4><p>线程1想要修改值，会</p>
<ul>
<li>先读取旧值</li>
<li>在修改前再次读取这个值</li>
<li>如果没人修改，则使用CAS进行修改这个值。</li>
<li>如果第二次读取的值和旧值不同，则CAS失败。</li>
</ul>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS：compare and set</p>
<p>在硬件级别保是原子操作，同一时间只有一个线程可以执行CAS。</p>
<p>ABA问题：线程1读取值A，线程2读取值A修改成B之后再修改成A，这样线程1不知道是不是被修改了。</p>
<p>解决：加上时间戳（版本号）</p>
<h3 id="JDK中的AQS的实现原理"><a href="#JDK中的AQS的实现原理" class="headerlink" title="JDK中的AQS的实现原理"></a>JDK中的AQS的实现原理</h3><p><code>ReentrantLock </code>类底层是AQS（Abstract Queue Synchronizer）</p>
<p>可以使用这个类生成一个锁lock，可以进行lock.lock() lock.unlock()实现互斥。</p>
<p>2.4.1 AQS会有一个等待队列，存储没有得到锁的线程，待锁释放后，按顺序为等待队列的线程提供锁</p>
<img src="http://gohoy.top/i/2023/07/31/ui6crn-1.png" alt="image-20230731160209376" style="zoom:80%;" />

<p>2.4.2如果在线程1执行完毕，唤醒线程2的过程中，如果有线程3想要加锁</p>
<ul>
<li>非公平锁：ReentrantLock lock &#x3D; new ReentrantLock()；<ul>
<li>线程3可能会成功得到锁，达到插队。</li>
</ul>
</li>
<li>公平锁：ReentrantLock lock &#x3D; new ReentrantLock(true);<ul>
<li>如果等待队列有线程，线程3会进入等待队列。</li>
</ul>
</li>
</ul>
<h3 id="线程池的底层工作原理"><a href="#线程池的底层工作原理" class="headerlink" title="线程池的底层工作原理"></a>线程池的底层工作原理</h3><p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险（阿里巴巴Java规范）</p>
<h4 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h4><p>提供一定量的线程，线程执行完成任务后，不销毁自己，等待下一次任务：</p>
<p><strong>避免重复创建和销毁线程，造成性能浪费</strong></p>
<p>创建线程池：</p>
<pre><code class="java">ExecutorService threadPool = Executor.newFixedThreadPool(10)  //(corePoolSize = 10)
threadPool.submit(new Callable() &#123;
    public void run()&#123;&#125;
&#125;);
</code></pre>
<p>有新任务的时候</p>
<ul>
<li>如果线程池的线程数量小于容量，则直接创建一个新的线程执行任务。</li>
<li>如果满了，则放在任务队列中。</li>
</ul>
<p>当线程完成自己的任务的时候，会去任务队列中获取任务，如果没有任务，会阻塞，不会销毁。</p>
<h4 id="线程池的核心配置参数"><a href="#线程池的核心配置参数" class="headerlink" title="线程池的核心配置参数"></a>线程池的核心配置参数</h4><p>代表线程池的类是ThreadPoolExecutor</p>
<pre><code class="java">return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;())
</code></pre>
<ul>
<li><code>corePoolSize：3</code><ul>
<li>一般最大线程数只有3</li>
</ul>
</li>
<li><code>maximumPoolSize：200</code><ul>
<li>当任务队列满了，可以最多额外创建到200个，执行任务并从任务队列获取任务</li>
</ul>
</li>
<li><code>keepAliveTime：60s</code><ul>
<li>任务队列空了60s后，额外线程自动会销毁掉</li>
</ul>
</li>
<li><code>new ArrayBlockingQueue&lt;Runnable&gt;(200)</code><ul>
<li>任务队列</li>
</ul>
</li>
</ul>
<p>如果额外线程也满了，会报异常。可以自定义RejectedExecutionHandler策略来应对这种情况：持久化被reject的任务，等负载低了再加载执行。</p>
<h4 id="如果在线程池中使用无界阻塞队列会发生什么问题"><a href="#如果在线程池中使用无界阻塞队列会发生什么问题" class="headerlink" title="如果在线程池中使用无界阻塞队列会发生什么问题"></a>如果在线程池中使用无界阻塞队列会发生什么问题</h4><p><strong>面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升</strong></p>
<p>调用超时，队列变得越来越大，内存会飙升，可能会导致OOM。</p>
<h4 id="线程池队列满了之后，会发生什么"><a href="#线程池队列满了之后，会发生什么" class="headerlink" title="线程池队列满了之后，会发生什么"></a>线程池队列满了之后，会发生什么</h4><ul>
<li>如果给maximumPoolSize设置太大，可能会导致系统崩溃。因为线程会占用一定内存，也会增加cpu负载。</li>
<li>如果给maximumPoolSize设置太小，可能会导致任务reject。</li>
</ul>
<h4 id="如果机器突然宕机，线程池的阻塞队列的任务怎么办"><a href="#如果机器突然宕机，线程池的阻塞队列的任务怎么办" class="headerlink" title="如果机器突然宕机，线程池的阻塞队列的任务怎么办"></a>如果机器突然宕机，线程池的阻塞队列的任务怎么办</h4><p><strong>都会丢失</strong></p>
<p>解决办法：在数据库对任务信息进行持久化。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>主要解决的问题：让每个线程绑定自己的值，防止竞争</p>
<p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><p>ThreadLocalMap 使用的key是对ThreadLocal的弱引用，value是强引用。垃圾回收的时候会回收弱引用对象，那么key可能会被回收，导致Map的key为null。如果我们不操作，value则无法被回收</p>
<p>ThreadLocalMap提供的方法：set get remove 都会清楚key为null 的记录。用完ThreadLocal之后最好进行remove()</p>
<h3 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h3><p>异步思想的典型运用。</p>
<p>耗时的任务交给future类实现，先执行其他步骤，等到我们需要的时候再通过future类获取。</p>
<pre><code class="java">// V 代表了Future执行的任务返回值的类型
public interface Future&lt;V&gt; &#123;
    // 取消任务执行
    // 成功取消返回 true，否则返回 false
    boolean cancel(boolean mayInterruptIfRunning);
    // 判断任务是否被取消
    boolean isCancelled();
    // 判断任务是否已经执行完成
    boolean isDone();
    // 获取任务执行结果
    V get() throws InterruptedException, ExecutionException;
    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutExceptio
&#125;
</code></pre>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p>InputStream&#x2F;Reader：输入流基类，前者是字节输入流，后者是字符输入流</p>
<p>OutputStream&#x2F;Writer：输出流基类，前者是字节输出流，后者是字符输出流</p>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
<li><code>available()</code>：返回输入流中可以读取的字节数。</li>
<li><code>close()</code>：关闭输入流释放相关的系统资源。</li>
</ul>
<p>JDK1.9之后添加了：</p>
<ul>
<li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。（实用）</li>
<li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
<pre><code class="java">try (InputStream fis = new FileInputStream(&quot;input.txt&quot;)) &#123;
    System.out.println(&quot;Number of remaining bytes:&quot;
            + fis.available());
    int content;
    long skip = fis.skip(2);
    System.out.println(&quot;The actual number of bytes skipped:&quot; + skip);
    System.out.print(&quot;The content read from file:&quot;);
    while ((content = fis.read()) != -1) &#123;
        System.out.print((char) content);
    &#125;
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
</code></pre>
<p>一般我们是不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流，后文会讲到）来使用。</p>
<pre><code class="java">// 新建一个 BufferedInputStream 对象
BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;input.txt&quot;));
// 读取文件的内容并复制到 String 对象中
String result = new String(bufferedInputStream.readAllBytes());
System.out.println(result);
</code></pre>
<h4 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h4><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p>
<pre><code class="java">FileInputStream fileInputStream = new FileInputStream(&quot;input.txt&quot;);
//必须将fileInputStream作为构造参数才能使用
DataInputStream dataInputStream = new DataInputStream(fileInputStream);
//可以读取任意具体的类型数据
dataInputStream.readBoolean();
dataInputStream.readInt();
dataInputStream.readUTF();
</code></pre>
<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p>
<pre><code class="java">ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;object.data&quot;));
MyClass object = (MyClass) input.readObject();
input.close();
</code></pre>
<p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p>
<h3 id="OutPutStream"><a href="#OutPutStream" class="headerlink" title="OutPutStream"></a>OutPutStream</h3><p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>write(int b)</code>：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code>：关闭输出流释放相关的系统资源。</li>
</ul>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<pre><code class="java">try (FileOutputStream output = new FileOutputStream(&quot;output.txt&quot;)) &#123;
    byte[] array = &quot;JavaGuide&quot;.getBytes();
    output.write(array);
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
</code></pre>
<p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code></p>
<pre><code class="java">FileOutputStream fileOutputStream = new FileOutputStream(&quot;output.txt&quot;);
BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream)
</code></pre>
<h4 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h4><p><strong><code>DataOutputStream</code></strong> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileOutputStream</code> 。</p>
<pre><code class="java">// 输出流
FileOutputStream fileOutputStream = new FileOutputStream(&quot;out.txt&quot;);
DataOutputStream dataOutputStream = new DataOutputStream(fileOutputStream);
// 输出任意数据类型
dataOutputStream.writeBoolean(true);
dataOutputStream.writeByte(1);
</code></pre>
<h4 id="ObjectInputStream-1"><a href="#ObjectInputStream-1" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（<code>ObjectInputStream</code>,反序列化），<code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)</p>
<pre><code class="java">ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;file.txt&quot;)
Person person = new Person(&quot;Guide哥&quot;, &quot;JavaGuide作者&quot;);
output.writeObject(person);
</code></pre>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类</p>
<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>
<li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
<h4 id="InputStreamReader-FileReader"><a href="#InputStreamReader-FileReader" class="headerlink" title="InputStreamReader FileReader"></a>InputStreamReader FileReader</h4><p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>
<pre><code class="java">try (FileReader fileReader = new FileReader(&quot;input.txt&quot;);) &#123;
    int content;
    long skip = fileReader.skip(3);
    System.out.println(&quot;The actual number of bytes skipped:&quot; + skip);
    System.out.print(&quot;The content read from file:&quot;);
    while ((content = fileReader.read()) != -1) &#123;
        System.out.print((char) content);
    &#125;
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
</code></pre>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>
<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
<h4 id="OutputStreamWriter-FileWriter"><a href="#OutputStreamWriter-FileWriter" class="headerlink" title="OutputStreamWriter FileWriter"></a>OutputStreamWriter FileWriter</h4><p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p>
<pre><code class="java">try (Writer output = new FileWriter(&quot;output.txt&quot;)) &#123;
    output.write(&quot;你好，我是Guide。&quot;);
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
</code></pre>
<h3 id="字符缓冲流BufferedInputStream-BufferedOutputStream"><a href="#字符缓冲流BufferedInputStream-BufferedOutputStream" class="headerlink" title="字符缓冲流BufferedInputStream BufferedOutputStream"></a>字符缓冲流BufferedInputStream BufferedOutputStream</h3><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>
<p>默认大小8M，可显式定义</p>
<h3 id="打印流-PrintStream"><a href="#打印流-PrintStream" class="headerlink" title="打印流 PrintStream"></a>打印流 PrintStream</h3><p>System.out就是一个PrintStream对象，print调用了write方法</p>
<p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code> （字符打印流）。<code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p>
<h3 id="随机访问流-RandomAccessFile"><a href="#随机访问流-RandomAccessFile" class="headerlink" title="随机访问流 RandomAccessFile"></a>随机访问流 RandomAccessFile</h3><p>可以访问到文件的任意字节。</p>
<p>适用于断点重传。</p>
<h2 id="谈谈对Java内存模型的理解"><a href="#谈谈对Java内存模型的理解" class="headerlink" title="谈谈对Java内存模型的理解"></a>谈谈对Java内存模型的理解</h2><pre><code class="java">public class HelloWorld &#123;
    private int data;
    public void increment()&#123;
        data++;
    &#125;
&#125;
HelloWorld helloWorld = new HelloWorld(); //对象存放在堆内存，包含对象中的实例变量
//线程1
new Thread()&#123;
    public void run()&#123;
        helloWorld.increment();
    &#125;
&#125;.start()
//线程2
new Thread()&#123;
    public void run()&#123;
        helloWorld.increment();
    &#125;
&#125;.start()
   
</code></pre>
<p>常量：主存（内存）</p>
<p>线程的工作内存：cpu缓存</p>
<p>常量操作：read load use assign store write</p>
<img src="http://gohoy.top/i/2023/07/31/ui6jyh-1.png" alt="image-20230731165920298" style="zoom: 80%;" />

<h3 id="可见性、原子性、有序性"><a href="#可见性、原子性、有序性" class="headerlink" title="可见性、原子性、有序性"></a>可见性、原子性、有序性</h3><ul>
<li>可见性<ul>
<li>没有可见性：线程1更新了数据，但是线程2看到的还是工作内存中旧的数据</li>
<li>有可见性：数据更新之后，线程1会强制使线程2重新读取修改后的数据。</li>
</ul>
</li>
<li>原子性<ul>
<li>一次只有一个线程进入临界区。data++必须是独立执行的。</li>
</ul>
</li>
<li>有序性<ul>
<li>在任务需要的资源准备完全之后，执行该线程任务。</li>
</ul>
</li>
</ul>
<h3 id="从底层角度聊volatile关键字原理"><a href="#从底层角度聊volatile关键字原理" class="headerlink" title="从底层角度聊volatile关键字原理"></a>从底层角度聊volatile关键字原理</h3><p>volatile：用来解决<strong>可见性和有序性</strong>，对原子性的保证很有限。（对64位的long型有一定原子性保证）</p>
<ul>
<li>实现可见性<ul>
<li><strong>当加上volatile的变量改变时，会使其他线程工作内存的过期变量失效。</strong></li>
</ul>
</li>
<li>保证有序性<ul>
<li>保证写在读之前</li>
</ul>
</li>
</ul>
<h3 id="指令重排和happens-before原则"><a href="#指令重排和happens-before原则" class="headerlink" title="指令重排和happens-before原则"></a>指令重排和happens-before原则</h3><p>指令重排有可能导致有序性失效。</p>
<p>happens-before原则：</p>
<ul>
<li>线程内按照代码顺序，写在前面的代码先行发生在卸载后面的代码。</li>
<li>锁定操作：对锁的unlock操作先行发生在lock操作</li>
<li>volatile变量原则：写操作在读操作之前</li>
<li>传递原则：A先于B，B先于C，则A先于C</li>
<li>线程启动原则：线程的启动thread.star()先于线程中的其他操作。还有interrupt</li>
<li>线程终结原则：线程的所有操作都先于线程的终止检测，使用thread.jion()结束。</li>
<li>对象终结原则：一个对象的初始化完成在finalize()方法之前。</li>
</ul>
<h3 id="volatile底层如何基于内存屏障保证可见性和有序性"><a href="#volatile底层如何基于内存屏障保证可见性和有序性" class="headerlink" title="volatile底层如何基于内存屏障保证可见性和有序性"></a>volatile底层如何基于内存屏障保证可见性和有序性</h3><p>对volatile的值的操作代码前后加上内存屏障。</p>
<p>内存屏障：禁止重排序</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring的IOC"><a href="#Spring的IOC" class="headerlink" title="Spring的IOC"></a>Spring的IOC</h3><p>如果没有IOC：tomcat+servlet：tomcat 监听端口来将请求转发给servlet来处理，耦合严重，需要变动时，修改很麻烦。</p>
<p>IOC：<strong>依赖注入，控制反转，容器根据xml配置或者注解来对bean对象之间的引用关系进行依赖注入</strong></p>
<p>底层核心技术：反射。根据类来自动构建对应的对象。</p>
<p>类与类彻底解耦。</p>
<p><img src="http://gohoy.top/i/2023/08/01/njxvd8-1.png" alt="image-20230801142412643"></p>
<h3 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h3><p>MySQL：事务：一次开启一个事务，其中进行多次增删改查。如果有一条失败了，会回滚事务，把这个事务中所有的sql语句都恢复。</p>
<p>AOP:做一个切面Aspect，给所有类似servicexxx代码之前都会开启一个事务，在这些方法运行完毕之后，根据是否抛出异常，去回滚或者提交事务。</p>
<p>核心技术：动态代理</p>
<p><strong>Spring会给正在运行的类生成动态代理类，包含我们写的类。然后在代理类中给逻辑前后加上事务。</strong></p>
<p>如何限定AOP。</p>
<p>TODO</p>
<h3 id="了解过cglib动态代理吗，他和jdk动态代理的区别是什么"><a href="#了解过cglib动态代理吗，他和jdk动态代理的区别是什么" class="headerlink" title="了解过cglib动态代理吗，他和jdk动态代理的区别是什么"></a>了解过cglib动态代理吗，他和jdk动态代理的区别是什么</h3><p>jdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。</p>
<p>没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。</p>
<h3 id="spring事务的实现原理是什么，事务传播机制是什么"><a href="#spring事务的实现原理是什么，事务传播机制是什么" class="headerlink" title="spring事务的实现原理是什么，事务传播机制是什么"></a>spring事务的实现原理是什么，事务传播机制是什么</h3><p>不同事务之间不互相影响</p>
<p>@Transactional(propagation &#x3D; Propagation.REQUIRED)会开启一个事务</p>
<ul>
<li>Propagation_REQUIRED：如果当前没有事务，创建一个事务，多个调用加入到一个事务中。</li>
<li>Propagation_SUPPORT：之前有事务则加入，没有则不开启。</li>
<li>Propagation_MANDATORY：有事务加入，没有则报错。</li>
<li>Propagation_RESQUIRES_NEW：强制开启一个新事务。</li>
<li>Propagation_NOT_SUPPORTED：不使用事务，有事务会挂起</li>
<li>Propagation_NEVER：不允许使用事务，有事务会报错</li>
<li>Propagation_NESTED：嵌套事务，外层事务回滚会导致内存事务也回滚，内层不影响外层。</li>
</ul>
<h3 id="Springboot-的核心架构"><a href="#Springboot-的核心架构" class="headerlink" title="Springboot 的核心架构"></a>Springboot 的核心架构</h3><p>自动装配依赖。不需要像spring一样自己配置xml文件，引入jar包。减少了配置。</p>
<h3 id="Spring-核心源码"><a href="#Spring-核心源码" class="headerlink" title="Spring 核心源码"></a>Spring 核心源码</h3><p>Spring bean 生命周期：</p>
<ul>
<li>创建bean<ul>
<li>实例化一个bean</li>
<li>依赖注入<ul>
<li>把这个bean的依赖的bean实例化，也进行依赖注入。注入方法：构造函数，setter方法。</li>
</ul>
</li>
<li>处理Aware接口<ul>
<li>如果这个bean实现了Aware相关的接口，Spring容器会把自己的信息注入给bean中。</li>
</ul>
</li>
<li>BeanPostProcesser<ul>
<li>在bean实例初始化之前和之后可以执行的方法。</li>
</ul>
</li>
<li>init初始化方法</li>
</ul>
</li>
<li>销毁<ul>
<li>DisposableBean接口，会调用这个接口实现的destroy方法</li>
<li>最后，如果配置了destroy-method方法，会调用这个方法</li>
</ul>
</li>
</ul>
<h3 id="Spring中的设计模式"><a href="#Spring中的设计模式" class="headerlink" title="Spring中的设计模式"></a>Spring中的设计模式</h3><p>工厂，单例，代理</p>
<p>工厂模式：使用工厂类来创建类。</p>
<p>单例模式：每个bean在系统运行期间只会创建一个实例对象。</p>
<p>代理模式：AOP</p>
<h3 id="SpringMVC架构"><a href="#SpringMVC架构" class="headerlink" title="SpringMVC架构"></a>SpringMVC架构</h3><ul>
<li>tomcat 监听端口，将请求转发给SpringMVC的DispathcherServlet</li>
<li>然后SpringMVC再根据url将请求转发给对应的controller</li>
<li>返回json给前端，前端符合渲染</li>
</ul>
<h3 id="SpringCloud核心架构"><a href="#SpringCloud核心架构" class="headerlink" title="SpringCloud核心架构"></a>SpringCloud核心架构</h3><p>这些框架</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进"><a href="#JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进" class="headerlink" title="JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进"></a>JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进</h3><ul>
<li>栈内存：每个线程独有</li>
<li>堆内存：存放对象、实例</li>
<li>永久代区域：我们写的类</li>
</ul>
<p>Java8以后永久代变成metaspace</p>
<p>常量区放在了堆里面</p>
<h3 id="JVM如何运行起来的，如何创建各种对象"><a href="#JVM如何运行起来的，如何创建各种对象" class="headerlink" title="JVM如何运行起来的，如何创建各种对象"></a>JVM如何运行起来的，如何创建各种对象</h3><p><strong>线程执行main函数同时创建对象</strong></p>
<p>Spring容器创建一些bean对象</p>
<p>把执行的方法和局部变量放在栈帧。</p>
<h3 id="JVM什么时候会触发垃圾回收"><a href="#JVM什么时候会触发垃圾回收" class="headerlink" title="JVM什么时候会触发垃圾回收"></a>JVM什么时候会触发垃圾回收</h3><p>内存分代：年轻代（eden：s1： s2，  8：1：1 ）和老年代</p>
<p>年轻代和老年代统称为堆</p>
<p>新生成的对象实例存放在年轻代。</p>
<ul>
<li>ygc：Eden区满了。进行youngGC<ul>
<li>没有引用的对象（类）被回收</li>
</ul>
</li>
</ul>
<p>年轻代垃圾回收算法：</p>
<ul>
<li>复制算法：因为年轻代中大多数都是垃圾对象，所以把存活对象复制到s1中，一键全部清除Eden区。<ul>
<li>把s1和Eden中的存活对象复制到s2，把s1和Eden区全部清除</li>
</ul>
</li>
</ul>
<h3 id="什么时候对象会转移到老年代"><a href="#什么时候对象会转移到老年代" class="headerlink" title="什么时候对象会转移到老年代"></a>什么时候对象会转移到老年代</h3><p>如果存活了多次垃圾回收过程，就会转移到老年代</p>
<p>如果s区放不下，会把一些存活的对象直接放到老年代中。</p>
<p>对于大对象会直接放到老年代中，防止ygc反复复制大对象。</p>
<h3 id="常用的垃圾回收器，老年代如何回收"><a href="#常用的垃圾回收器，老年代如何回收" class="headerlink" title="常用的垃圾回收器，老年代如何回收"></a>常用的垃圾回收器，老年代如何回收</h3><p>老年代中大多数是长期存活的对象，所以使用标记-清理方法：把所有存活的对象压缩到连续的位置，然后统一清理，可以防止内存碎片问题。</p>
<p>常用的垃圾回收器：</p>
<ul>
<li>CMS+parnew jdk8-jdk9</li>
<li>g1 jdk11 </li>
<li>ZGC</li>
</ul>
<h3 id="生产环境如何设置jvm参数的，如何检查jvm的运行情况"><a href="#生产环境如何设置jvm参数的，如何检查jvm的运行情况" class="headerlink" title="生产环境如何设置jvm参数的，如何检查jvm的运行情况"></a>生产环境如何设置jvm参数的，如何检查jvm的运行情况</h3><p>tomcat的配置脚本，catalina脚本设置。</p>
<p>如果使用jar启动，再java命令后直接加上参数</p>
<p>参数：</p>
<ul>
<li>内存区域大小的分配：<ul>
<li>栈大小</li>
<li>metaspace大小</li>
<li>eden  survivor</li>
<li>堆大小</li>
<li>年轻代、老年代</li>
</ul>
</li>
<li>垃圾回收器<ul>
<li>年轻代和老年代用了什么回收器</li>
<li>是否有特殊参数，作用是什么</li>
</ul>
</li>
</ul>
<p>jstat压测，QPS,接口性能</p>
<h3 id="JVM-GC优化"><a href="#JVM-GC优化" class="headerlink" title="JVM GC优化"></a>JVM GC优化</h3><p>自己动手进行压测，调试一下</p>
<h3 id="发生OOM之后，应该如何排查和处理线上系统的OOM问题"><a href="#发生OOM之后，应该如何排查和处理线上系统的OOM问题" class="headerlink" title="发生OOM之后，应该如何排查和处理线上系统的OOM问题"></a>发生OOM之后，应该如何排查和处理线上系统的OOM问题</h3><p>在jvm设置参数，发生oom之后保存快照。</p>
<p>找出占用内存最大的对象和创建它的代码，进行调优。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="TCP-IP的四层模型和七层网络模型"><a href="#TCP-IP的四层模型和七层网络模型" class="headerlink" title="TCP&#x2F;IP的四层模型和七层网络模型"></a>TCP&#x2F;IP的四层模型和七层网络模型</h3><p>TCP&#x2F;IP四层：数据链路层、网络层、传输层、应用层</p>
<ul>
<li>物理层：硬件部分</li>
<li>数据链路层：将0&#x2F;1信号分组，确定来源去向<ul>
<li>以太网协议：一组信号是一个网络帧。每帧有两个部分：表头和数据，表头保存说明性的东西，比如发送者，接收者，数据类型等。通过网卡来发送接收数据，mac地址是网卡的id。</li>
<li>mac：前6个16进制是厂商编号，后6个编号是网卡流水号。</li>
</ul>
</li>
<li>网络层：<ul>
<li>IP协议</li>
<li>判断是不是一个子网：使用ip的二进制和子网掩码进行与运算，看结果前三个部分如果是一样的就是子网。</li>
<li>不在一个子网需要一个路由器，路由器判断数据包的目标mac是不是自己的子网内的mac，是则转发。</li>
<li>ARP cache 会让每一个电脑都缓存到子网中所以电脑的ip和mac对应关系。</li>
<li>路由器就可以看做是一个网关</li>
</ul>
</li>
<li>传输层TCP协议：仅仅规定了基于端口的点对点通信协议，包含如何建立连接，读取和发送信息。要基于TCP 开发，实际上是使用socket开发。</li>
<li>应用层：最常见的是http</li>
</ul>
<p>OSI七层：物理层、会话层、表示层 + 四层模型</p>
<p>DNS：domain name server ，先通过dns服务器把域名翻译成IP。</p>
<h3 id="浏览器访问baidu-com会发生什么"><a href="#浏览器访问baidu-com会发生什么" class="headerlink" title="浏览器访问baidu.com会发生什么"></a>浏览器访问baidu.com会发生什么</h3><ul>
<li>域名解析为IP</li>
<li>把请求打包成http包</li>
<li>把http数据包包装成tcp数据包，tcp数据头包含接收者和发送者的端口号</li>
<li>然后把全部数据包包装到ip数据包，ip数据头中包含发送者和接收者的ip</li>
<li>然后以太网会把这个数据包封装到以太网数据包中，加上以太网头，其中包含有发送者和接收者的网卡mac地址。<ul>
<li>以太网一次传输字节有限，可能需要切割为多个包。</li>
<li>根据IP头序号来合成一个包。</li>
</ul>
</li>
<li>然后通过多个路由转发到百度的子网中。</li>
</ul>
<h3 id="TCP三次握手和四次挥手的流程，为什么不是五次或者两次？"><a href="#TCP三次握手和四次挥手的流程，为什么不是五次或者两次？" class="headerlink" title="TCP三次握手和四次挥手的流程，为什么不是五次或者两次？"></a>TCP三次握手和四次挥手的流程，为什么不是五次或者两次？</h3><ul>
<li>建立连接的三次握手：<ul>
<li>客户端发送syn（同步），表示自己进入了syn_send状态</li>
<li>服务端恢复syn+ack（确认）表示确认收到同步请求，并且自己进入syn_recevie状态</li>
<li>客户端发送ack，表示确认建立连接。当服务端接收到这个包的时候，连接正式建立</li>
</ul>
</li>
<li>为什么不是两次握手<ul>
<li>如果网络问题，遇到不想要的连接，三次连接可以让客户端发送给服务器复位信息，释放资源</li>
</ul>
</li>
<li>结束连接的四次挥手：<ul>
<li>客户端发送FIN（结束）</li>
<li>服务端发送ACK（收到），这段时间有可能传输还没有完全完毕，等待全部完毕后再发送FIN。</li>
<li>服务端发送FIN（结束）</li>
<li>客户端发送ACK（收到）：服务端收到这个请求后立刻关闭，客户端会等待一段时间，保证服务端确实接收到这个包</li>
</ul>
</li>
</ul>
<p> 2 3次挥手好像在某些情况可以合并？</p>
<h3 id="说一下http长连接的原理"><a href="#说一下http长连接的原理" class="headerlink" title="说一下http长连接的原理"></a>说一下http长连接的原理</h3><p><strong>http本身没有长连接，都是tcp的长连接和短链接</strong></p>
<p>http协议规范：请求头，请求体什么的</p>
<p>http1.0 都是短链接，一次请求后直接断开tcp连接，需要指定keep-alive才能建立长连接</p>
<p>http1.1 默认是长连接</p>
<p>http2.0支持多路复用，一个tcp可以并行发送多个请求以及接收响应。</p>
<p>http3.0 QUIC 建立在udp之上。</p>
<h3 id="https-http-ssl-tsl"><a href="#https-http-ssl-tsl" class="headerlink" title="https http+ssl&#x2F;tsl"></a>https http+ssl&#x2F;tsl</h3><p>使用证书加密</p>
<ul>
<li>非对称加密：rsa<ul>
<li>网站给浏览器发送证书（由权威机构颁发），浏览器验证合法性</li>
<li>浏览器生成随机密码，用随机密码加密随机密码的hash，并且用证书的公钥加密这个随机密码，</li>
<li>网站用证书的私钥解密这个随机面膜，再用随机密码解密得到hash，计算自己得到的密码的hash进行对比，如果完全相同，则可以使用</li>
<li>之后用这个随机密码来实现加密通信。</li>
</ul>
</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="引擎：mysiam-innodb"><a href="#引擎：mysiam-innodb" class="headerlink" title="引擎：mysiam innodb"></a>引擎：mysiam innodb</h3><ul>
<li>mysiam：不支持事务，不支持外键约束。索引和数据文件分开，可以在内存缓存更多索引，查询性能会更好，适用于少量插入，大量查询<ul>
<li>hadoop报表系统，用mysql mysiam比较适合，但是数据量太大超过500w以上就也不能用mysql了。</li>
</ul>
</li>
<li>innodb（默认）：支持事务，外键约束，高并发，高可用，大数据量</li>
</ul>
<h3 id="Mysql索引原理和数据结构。"><a href="#Mysql索引原理和数据结构。" class="headerlink" title="Mysql索引原理和数据结构。"></a>Mysql索引原理和数据结构。</h3><p>索引：默认b+树</p>
<ul>
<li>b-树<ul>
<li>每个节点都存储对应的data</li>
</ul>
</li>
<li>b+树<ul>
<li>只有叶子节点存储对应的data</li>
</ul>
</li>
</ul>
<p>Mysiam的索引：叶子节点存储的是索引的物理地址。然后用物理地址去数据文件找数据。</p>
<p>Innodb的索引：表要求必须要有主键，默认会为主键建立一个索引，节点data包含所有数据（一个记录，整行），叫做聚簇索引。如果你使用name来找数据，那么从name索引中找到的data是主键（id），再用id从聚簇索引找data。</p>
<h3 id="索引的使用规则"><a href="#索引的使用规则" class="headerlink" title="索引的使用规则"></a>索引的使用规则</h3><p>怎么建立索引？</p>
<p><strong>最左前缀匹配原则：</strong></p>
<p>创建联合索引：create index(shop_id,product_id,gmt_create)</p>
<p>如果你使用 shop_id 和 gmt_create来查找，那么不会直接通过这个联合索引查找，而是通过使用shop_id筛选出来一些数据，之后扫描gmt_create字段符合要求过滤。（性能也还行）。</p>
<p><strong>但如果没有最左边的任何字段，就没法用这个索引</strong>，比如直接通过product_id查找，这个是没有用到这个索引的。</p>
<p>范围列匹配，最左前缀范围查找会用索引，之后的不会用索引了。</p>
<p>调用了函数的sql语句不使用索引</p>
<p><strong>建立尽量少的索引，10条以内为佳</strong></p>
<p><strong>尽量选唯一字段进行建立索引</strong>。选择的字段 去重后数量&#x2F;总数量 ，结果要是小，则说明这个索引用处不大。</p>
<h3 id="事务的几个特点"><a href="#事务的几个特点" class="headerlink" title="事务的几个特点"></a>事务的几个特点</h3><p><strong>ACID</strong></p>
<ul>
<li>Atomic：原子性，同时执行的sql要么一起成功，要么一起失败</li>
<li>Consistency：一致性，事务之前前后数据都应该是正确的</li>
<li>Isolation：隔离性，多个事务之间不互相干扰</li>
<li>Durability：持久性</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li>读未提交：事务A读取到事务B还没有提交的数据</li>
<li>读已提交：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到不一样的数据。（不可重复读）</li>
<li>可重复读：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到的还是事务A最开始读取到的数据。（可重复读）</li>
<li>幻读（不是隔离级别）：事务A查询所有数据，准备插入一一条数据，事务B插入了一行数据，事务B提交插入。事务A想要插入数据，发现这个数据已经存在（被事务B插入）。</li>
<li>串行化（为了解决幻读）：事务A查询所有数据，事务B想要插入一行数据会被拒绝。事务A提交后，事务B才能进行插入数据。</li>
</ul>
<p><strong>MySQL默认级别：可重复读。</strong></p>
<p><strong>实现可重复读的机制</strong>：MVCC机制 multi-version concurrency control</p>
<ul>
<li><p>事务id是全局唯一且递增的，</p>
</li>
<li><p>查询事务只会找比自己事务id小的 创建事务。</p>
<ul>
<li><p>创建事务id&lt;&#x3D;当前事务id</p>
</li>
<li><p>当前事务id&lt;删除事务id</p>
</li>
</ul>
</li>
<li><p>不同事务修改某行数据，会多出来一行，id相同。</p>
</li>
</ul>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><p><strong>自动加锁</strong></p>
<p>表锁 行锁 页锁</p>
<ul>
<li>myisam会加表锁。锁表的时候查询会报504</li>
</ul>
<p>行锁：innodb：共享锁（s）和排他锁（x）</p>
<ul>
<li>共享锁和排他锁不能同时加</li>
<li>select 不加锁因为MVCC有快照，增删改会加一个行锁排他锁。</li>
</ul>
<p><strong>手动加锁</strong></p>
<p>加共享锁：select * from table where id &#x3D; 1 lock in share mode</p>
<p>加排他锁：select * from table where id &#x3D;1 for update</p>
<p><strong>悲观锁</strong>：进行操作都加上排他锁</p>
<p><strong>乐观锁</strong>：加上版本号字段，在事务修改期间如果版本号不同，则这次修改失败，需要重新读取操作。</p>
<p><strong>死锁</strong>：dba查看死锁日志。</p>
<h3 id="MySQL调优的常用手段"><a href="#MySQL调优的常用手段" class="headerlink" title="MySQL调优的常用手段"></a>MySQL调优的常用手段</h3><ul>
<li>保持sql简单，建议使用单表查询<ul>
<li>优化索引</li>
<li>查看sql的执行计划：explain select * from table</li>
</ul>
</li>
</ul>
<h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p>entities-relationship图</p>
<p>关系：操作数是关系，重复行的对应关系（投影）要去掉。剩下的是关系：一对多，一对一，多对多等</p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>直接使用tcp进行通信，就是socket编程</p>
<p>可以认为socket处于传输层。或者是介于传输层和应用层直接。</p>
<p>socket 就是封装了tcp的编程规范</p>
<h2 id="进程通信和线程切换"><a href="#进程通信和线程切换" class="headerlink" title="进程通信和线程切换"></a>进程通信和线程切换</h2><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>9.1.1管道 pipe</p>
<p>只有父子进程（fork得到的）才能使用这个管道进行通信。</p>
<p>9.1.2命名管道</p>
<p>无亲缘关系的管道可以使用命名管道通信</p>
<p>9.1.3消息队列</p>
<p>9.1.4共享内存</p>
<h3 id="线程如何切换"><a href="#线程如何切换" class="headerlink" title="线程如何切换"></a>线程如何切换</h3><p>时间片轮换</p>
<p>优先级调度等</p>
<h2 id="nio，bio，aio都是什么，有什么区别。nio的原理是什么"><a href="#nio，bio，aio都是什么，有什么区别。nio的原理是什么" class="headerlink" title="nio，bio，aio都是什么，有什么区别。nio的原理是什么"></a>nio，bio，aio都是什么，有什么区别。nio的原理是什么</h2><h3 id="bio通信原理"><a href="#bio通信原理" class="headerlink" title="bio通信原理"></a>bio通信原理</h3><p>服务端使用ServerSocket为每一个客户端建立一个线程用于通信。只要客户端还和服务端有连接，这个线程都要等待。</p>
<p>问题：超过几千客户端就不能够正常运行了</p>
<h3 id="nio通信原理"><a href="#nio通信原理" class="headerlink" title="nio通信原理"></a>nio通信原理</h3><p>每有一个客户端和服务端建立连接，都会创建一个channel，这些channel都会注册在selector中，这个selector只有一个线程。会不断轮询这些channel。，如果有请求过来，会创建一个线程来处理这个请求。处理完成后这个线程会被销毁。</p>
<p>可以对处理请求的线程创建一个线程池。</p>
<p>在工作线程和channel 直接可以维护一个cache</p>
<p>工作线程从channel 中读取数据，给channel写数据，是同步的</p>
<h3 id="aio"><a href="#aio" class="headerlink" title="aio"></a>aio</h3><p>对nio有优化：工作进程从channel读数据的时候，会绑定一个buffer，让操作系统来完成读操作，读完了来通知这个线程。</p>
<p>写的时候也是把写的过程交给操作系统。</p>
<h3 id="同步阻塞、同步非阻塞、异步非阻塞"><a href="#同步阻塞、同步非阻塞、异步非阻塞" class="headerlink" title="同步阻塞、同步非阻塞、异步非阻塞"></a>同步阻塞、同步非阻塞、异步非阻塞</h3><p>BIO是同步阻塞，针对的是对磁盘文件的io读写。读写过程中线程阻塞</p>
<p>NIO是同步非阻塞，在操作系统读写数据的时候，线程可以做其他事情，但是也需要不断轮询判断读写完成了没有。</p>
<p>AIO 是异步非阻塞，发起文件读写的操作之后，交给操作系统，操作系统执行完毕之后，会通知这个线程。</p>
<h3 id="BIO-NIO-AIO-demo代码"><a href="#BIO-NIO-AIO-demo代码" class="headerlink" title="BIO NIO AIO demo代码"></a>BIO NIO AIO demo代码</h3><p>TOREAD</p>
<h2 id="线上服务器问题"><a href="#线上服务器问题" class="headerlink" title="线上服务器问题"></a>线上服务器问题</h2><h3 id="线上CPU占用100-，排查步骤："><a href="#线上CPU占用100-，排查步骤：" class="headerlink" title="线上CPU占用100%，排查步骤："></a>线上CPU占用100%，排查步骤：</h3><ul>
<li>top -c 输入P ，按照cpu进行排序</li>
<li>top -Hp pid ，可以看到这个进程的负载</li>
<li>把线程pid换成16进制pidhex，如何使用jstack pid | grep pidhex -C5 –color 就可以定位到线程中哪行代码的cpu占用最高。</li>
</ul>
<h3 id="如果线上进程kill不掉怎么办"><a href="#如果线上进程kill不掉怎么办" class="headerlink" title="如果线上进程kill不掉怎么办"></a>如果线上进程kill不掉怎么办</h3><p>ps aux 查看是否有僵尸进程 zombie</p>
<p>ps -ef  | grep 僵尸进程id ，得到父进程id</p>
<p>然后kill 父进程之后kill子进程。</p>
<h3 id="磁盘马上占满了怎么办"><a href="#磁盘马上占满了怎么办" class="headerlink" title="磁盘马上占满了怎么办"></a>磁盘马上占满了怎么办</h3><p>是否是日志占满空间了？</p>
<p>经历：安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志&#x2F;var&#x2F;log&#x2F;pcp&#x2F;pmlogger&#x2F;openEuler1&#x2F;。</p>
<p>关于pcp：</p>
<ul>
<li>Performance Co-Pilot (<code>pcp</code>) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。 	</li>
<li>这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。</li>
</ul>
<p> 	</p>
<p>find &#x2F; -size+100M | xargs ls -lh  找大于100m的文件</p>
<h2 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a>Java语言特性</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul>
<li>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本</li>
</ul>
</li>
<li>想要通过传值来修改原来的值<ul>
<li>通过数组</li>
<li>通过类</li>
<li>或者其他可变的引用类型</li>
</ul>
</li>
<li>不可变的引用类型<ul>
<li>String</li>
<li>Integer</li>
<li>BigDecimal</li>
<li>LocalDate、LocalTime、LocalDateTime、Duration，Period</li>
</ul>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li><p>序列化协议属于应用层或者传输层</p>
</li>
<li><p>序列化的对象：实现Serializable 接口的类、实例变量的值、非静态成员变量</p>
</li>
<li><p>serialVersionUID：用来判断对象版本。手动设置这个变量可以解决对象版本兼容问题。</p>
</li>
<li><p>Kryo用来序列化Java代码性能高。</p>
<ul>
<li><pre><code class="java">import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

import java.io.*;

public class KryoSerializationExample &#123;
    public static void main(String[] args) &#123;
        // 创建 Kryo 对象
        Kryo kryo = new Kryo();

        // 创建要序列化的对象
        Person person = new Person(&quot;Alice&quot;, 30);

        // 序列化
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        Output output = new Output(outputStream);
        kryo.writeObject(output, person);
        output.close();

        // 将序列化的数据保存到文件
        try (FileOutputStream fileOutputStream = new FileOutputStream(&quot;person.dat&quot;)) &#123;
            outputStream.writeTo(fileOutputStream);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;

        // 反序列化
        try (FileInputStream fileInputStream = new FileInputStream(&quot;person.dat&quot;)) &#123;
            // 创建 Kryo 输入流
            Input input = new Input(fileInputStream);

            // 从输入流中反序列化对象
            Person deserializedPerson = kryo.readObject(input, Person.class);
            input.close();

            // 使用反序列化后的对象
            System.out.println(&quot;姓名: &quot; + deserializedPerson.getName());
            System.out.println(&quot;年龄: &quot; + deserializedPerson.getAge());
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="泛型和通配符"><a href="#泛型和通配符" class="headerlink" title="泛型和通配符"></a>泛型和通配符</h3><ol>
<li>泛型（Generics）：泛型允许在编译时指定类、接口或方法操作的数据类型，以提供类型安全和代码重用。通过使用泛型，可以在编译时捕获类型错误，并避免在运行时出现类型转换错误。<ul>
<li>定义泛型类：使用 <code>&lt;T&gt;</code> 来表示类型参数，可以在类名后面声明一个泛型类型。例如：<code>class MyClass&lt;T&gt; &#123; ... &#125;</code>。</li>
<li>定义泛型方法：使用 <code>&lt;T&gt;</code> 来表示类型参数，可以在方法返回类型前声明一个泛型类型。例如：<code>&lt;T&gt; T myMethod(T obj) &#123; ... &#125;</code>。</li>
<li>约定<ul>
<li><code>E</code>：表示集合中的元素类型。</li>
<li><code>K</code>：表示映射中的键类型。</li>
<li><code>V</code>：表示映射中的值类型。</li>
<li><code>T</code>：表示任意类型。</li>
<li><code>S</code>、<code>U</code>、<code>V</code>：用于表示第二、第三和第四类型参数。</li>
</ul>
</li>
</ul>
</li>
<li>类型通配符（Wildcard）：类型通配符用问号 <code>?</code> 表示，用于灵活处理不同类型的泛型对象。通配符可以用于泛型类、泛型方法和通配符限定。<ul>
<li>通配符限定上界：<code>? extends Type</code>，表示泛型参数是 Type 类型或其子类。例如：<code>List&lt;? extends Number&gt;</code> 表示一个只能接受 Number 及其子类的 List。</li>
<li>通配符限定下界：<code>? super Type</code>，表示泛型参数是 Type 类型或其父类。例如：<code>List&lt;? super Integer&gt;</code> 表示一个只能接受 Integer 及其父类的 List。</li>
<li>无限制通配符：<code>?</code>，表示可以是任意类型。例如：<code>List&lt;?&gt;</code> 表示一个可以接受任意类型的 List。</li>
</ul>
</li>
</ol>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><pre><code class="java">//获取类
Class&lt;?&gt; myClass = MyClass.class;
Class&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);
//获取构造函数
Constructor&lt;?&gt; constructor = myClass.getDeclaredConstructor(parameterTypes);
//创建对象
Object myObject = constructor.newInstance(arguments);
//获取方法
Method method = myClass.getDeclaredMethod(&quot;methodName&quot;, parameterTypes);
//调用方法
method.invoke(myObject, arguments);
//获取字段
Field field = myClass.getDeclaredField(&quot;fieldName&quot;);
//获取字段的值
Object fieldValue = field.get(myObject);
//设置字段的值
field.set(myObject, value);
//对于私有方法或字段，可能需要使用setAccessible(true)来绕过访问限制。
</code></pre>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h5 id="1-静态代理："><a href="#1-静态代理：" class="headerlink" title="1.静态代理："></a>1.静态代理：</h5><p>就是把在调用类的前后在执行一些步骤。</p>
<pre><code class="java">public class SmsProxy implements SmsService &#123;

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) &#123;
        this.smsService = smsService;
    &#125;

    @Override
    public String send(String message) &#123;
        //调用方法之前，我们可以添加自己的操作
        System.out.println(&quot;before method send()&quot;);
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println(&quot;after method send()&quot;);
        return null;
    &#125;
&#125;
</code></pre>
<h5 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h5><p><strong>2.1JDK代理：在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<pre><code class="java">//调用proxy的方法newProxyInstance
Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new DebugInvocationHandler(target));
//DebugInvocationHandler 是自定义的proxy方法，需要实现InvocationHandler接口的invoke方法，实际上是调用了这里的invoke方法
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
public class DebugInvocationHandler implements InvocationHandler &#123;
    private final Object target;
    public DebugInvocationHandler(Object target) &#123;
        this.target = target;
    &#125;
    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;
        System.out.println(&quot;before Method&quot;+ method.getName());
        Object result = method.invoke(target, objects);
        System.out.println(&quot;after Method&quot;+ method.getName());
        return result;
    &#125;
&#125;
</code></pre>
<p>JDK 动态代理有一个最致命的问题是其<strong>只能代理实现了接口的类</strong>。</p>
<p>为了解决这个问题，我们可以用 CGLIB 动态代理机制。</p>
<p><strong>2.2CGLIB代理</strong></p>
<ul>
<li><p>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</p>
</li>
<li><p>maven依赖：</p>
<ul>
<li><pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;cglib&lt;/groupId&gt;
  &lt;artifactId&gt;cglib&lt;/artifactId&gt;
  &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
<li><pre><code class="java">//代理工厂中生成一个 enhancer对象，这个对象拥有下列属性，其中DebugMethodInterceptor拦截器是自定义的最终执行的方法
public class CglibProxyFactory &#123;
    public static Object getProxy(Class&lt;?&gt; clazz)&#123;
        Enhancer enhancer = new Enhancer();
        enhancer.setClassLoader(clazz.getClassLoader());
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(new DebugMethodInterceptor());
        return enhancer.create();
    &#125;
&#125;
//DebugMethodInterceptor 实现MethodInterceptor接口，重写intercept方法，这个方法相当于前面的invoke
public class DebugMethodInterceptor implements MethodInterceptor &#123;
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
        //调用方法之前，我们可以添加自己的操作
        System.out.println(&quot;before method &quot; + method.getName());
        Object object = methodProxy.invokeSuper(o, objects);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println(&quot;after method &quot; + method.getName());
        return object;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>2.3二者的区别</strong></p>
<p>jdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。</p>
<p>没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。</p>
<h3 id="BigDecimal常见方法"><a href="#BigDecimal常见方法" class="headerlink" title="BigDecimal常见方法"></a>BigDecimal常见方法</h3><p>我们在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>
<p><strong>使用BigDecimal(double val)会丢失精度</strong></p>
<p>方法：</p>
<ul>
<li>add：加</li>
<li>subtract：减</li>
<li>multiple：乘</li>
<li>divide：除<ul>
<li>除的时候尽量使用三个参数的版本：指定保留规则RoundingMode</li>
</ul>
</li>
<li>compareTo：<code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1 表示 <code>a</code> 大于 <code>b</code>。<ul>
<li>比较不能使用equals，因为equals比较会同时比较精度，1.0和1.00不相同</li>
</ul>
</li>
<li>setScale：保留小数</li>
</ul>
<p>工具类：</p>
<details><summary>点击查看代码</summary>
 <pre><code>
import java.math.BigDecimal;
import java.math.RoundingMode;
/**
 * 简化BigDecimal计算的小工具类
 */
public class BigDecimalUtil &#123;
    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;
    private BigDecimalUtil() &#123;
    &#125;
    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) &#123;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.add(b2).doubleValue();
    &#125;
    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double subtract(double v1, double v2) &#123;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.subtract(b2).doubleValue();
    &#125;
    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double multiply(double v1, double v2) &#123;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.multiply(b2).doubleValue();
    &#125;
    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2) &#123;
        return divide(v1, v2, DEF_DIV_SCALE);
    &#125;
    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2, int scale) &#123;
        if (scale < 0) &#123;
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        &#125;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();
    &#125;
    /**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v, int scale) &#123;
        if (scale < 0) &#123;
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        &#125;
        BigDecimal b = BigDecimal.valueOf(v);
        BigDecimal one = new BigDecimal("1");
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    &#125;
    /**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static float convertToFloat(double v) &#123;
        BigDecimal b = new BigDecimal(v);
        return b.floatValue();
    &#125;
    /**
     * 提供精确的类型转换(Int)不进行四舍五入
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static int convertsToInt(double v) &#123;
        BigDecimal b = new BigDecimal(v);
        return b.intValue();
    &#125;
    /**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static long convertsToLong(double v) &#123;
        BigDecimal b = new BigDecimal(v);
        return b.longValue();
    &#125;
    /**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */
    public static double returnMax(double v1, double v2) &#123;
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.max(b2).doubleValue();
    &#125;
    /**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */
    public static double returnMin(double v1, double v2) &#123;
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.min(b2).doubleValue();
    &#125;
    /**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */
    public static int compareTo(double v1, double v2) &#123;
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.compareTo(b2);
    &#125;
&#125;
    </code></pre>
</details>

<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/unsafe.html">Unsafe类</a></h3><p>在JUC高并发编程中主要使用，用来执行本地方法（native方法）。</p>
<p>native方法的执行绕过了Java本身的界限。能直接接触到操作系统底层的某些功能，因此并不安全。</p>
<p>可以实现的功能：</p>
<ol>
<li>内存操作</li>
<li>内存屏障</li>
<li>对象操作</li>
<li>数据操作</li>
<li>CAS 操作</li>
<li>线程调度</li>
<li>Class 操作</li>
<li>系统信息</li>
</ol>
<p>因为其不安全性，并不推荐使用。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><h4 id="字符串最长匹配串（KMP）"><a href="#字符串最长匹配串（KMP）" class="headerlink" title="字符串最长匹配串（KMP）"></a>字符串最长匹配串（KMP）</h4><p>核心：对于匹配串生成一个失配表，根据失配表进行匹配</p>
<p>失配表：匹配串的第几位没有匹配成功，再从匹配串的某一位重新匹配</p>
<h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><p>调用replace方法即可</p>
<h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><p>先利用 Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可（sort的时候数字排在最前面）</p>
<h4 id="构建回文串"><a href="#构建回文串" class="headerlink" title="构建回文串"></a>构建回文串</h4><ul>
<li>出现的字符次数是偶数的情况</li>
<li>出现的字符次数是偶数的组合+最长的奇数组合</li>
</ul>
<h4 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h4><p>从两边向中间遍历</p>
<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><p>**动态规划： **TOREAD</p>
<pre><code> dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])
</code></pre>
<h4 id="括号的匹配深度"><a href="#括号的匹配深度" class="headerlink" title="括号的匹配深度"></a>括号的匹配深度</h4><p>while(replace(“()”,””) !&#x3D; -1)</p>
<h4 id="字符串转换为整数"><a href="#字符串转换为整数" class="headerlink" title="字符串转换为整数"></a>字符串转换为整数</h4><p>实现 Integer.valueOf(string)的功能，但是 string 不符合数字要求时返回 0</p>
<pre><code class="java">//https://www.weiweiblog.cn/strtoint/
public class Main &#123;

  public static int StrToInt(String str) &#123;
    if (str.length() == 0)
      return 0;
    char[] chars = str.toCharArray();
    // 判断是否存在符号位
    int flag = 0;
    if (chars[0] == &#39;+&#39;)
      flag = 1;
    else if (chars[0] == &#39;-&#39;)
      flag = 2;
    int start = flag &gt; 0 ? 1 : 0;
    int res = 0;// 保存结果
    for (int i = start; i &lt; chars.length; i++) &#123;
      if (Character.isDigit(chars[i])) &#123;// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False
        int temp = chars[i] - &#39;0&#39;;
        res = res * 10 + temp;
      &#125; else &#123;
        return 0;
      &#125;
    &#125;
   return flag != 2 ? res : -res;

  &#125;

  public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    String s = &quot;-12312312&quot;;
    System.out.println(&quot;使用库函数转换：&quot; + Integer.valueOf(s));
    int res = Main.StrToInt(s);
    System.out.println(&quot;使用自己写的方法转换：&quot; + res);

  &#125;

&#125;
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 2738430398@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2023- Gohoy
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/blog/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/blog/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







<div id="musicMouseDrag" style="position:fixed; z-index: 9999; bottom: 0; right: 0;">
<div id="musicDragArea" style="position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;"></div>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=8700654240&auto=1&height=430"></iframe>
</div>
<!--以下代码是为了支持随时拖动音乐控件的位置，如没有需求，可去掉下面代码-->
<script>
var $DOC = $(document)
$('#musicMouseDrag').on('mousedown', function (e) {
// 阻止文本选中
$DOC.bind("selectstart", function () {
return false;
});
$('#musicDragArea').css('height', '100%');
var $moveTarget = $('#musicMouseDrag');
$moveTarget.css('border', '1px dashed grey')
var div_x = e.pageX - $moveTarget.offset().left;
var div_y = e.pageY - $moveTarget.offset().top;
$DOC.on('mousemove', function (e) {
var targetX = e.pageX - div_x;
var targetY = e.pageY - div_y;
targetX = targetX < 0 ? 0 : (targetX + $moveTarget.outerWidth() >= window.innerWidth) ? window.innerWidth - $moveTarget.outerWidth() : targetX;
targetY = targetY < 0 ? 0 : (targetY + $moveTarget.outerHeight() >= window.innerHeight) ? window.innerHeight - $moveTarget.outerHeight() : targetY;
$moveTarget.css({'left': targetX + 'px', 'top': targetY + 'px', 'bottom': 'inherit', 'right': 'inherit'})
}).on('mouseup', function () {
$DOC.unbind("selectstart");
$DOC.off('mousemove')
$DOC.off('mouseup')
$moveTarget.css('border', 'none')
$('#musicDragArea').css('height', '10px');
})
})
</script>
</html>
